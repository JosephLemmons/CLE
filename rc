#!/bin/sh
#
## ** CLE : Command Live Environment **
#
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* version: 2018-10-18 (Zodiac)
#* license: GNU GPL v2
#* Copyright (C) 2016-2018 by Michael Arbet

# Debugging helpers							# dbg
dbg_echo () { [ $CLE_DEBUG ] && echo "$*" >/dev/tty; }			# dbg
dbg_var () (								# dbg
	[ $ZSH_NAME ] && V=${(P)1} || V=${!1}				# dbg
	[ $CLE_DEBUG ] && printf "%-16s = %s\n" $1 "$V" >/dev/tty	# dbg
)									# dbg
#: ^^^ This was first bit of zsh/bash compatible code			# dbg
[ -f $HOME/CLEDEBUG ] && { CLE_DEBUG=1; }				# dbg
#CLE_DEBUG=1	# force debugging on or comment this line		# dbg
dbg_echo; dbg_echo CLE pid:$$ DEBUG ON;					# dbg


# Startup sequence
#: First check how is this script executed
#:  - in case of a shell resource, this will be interactive session,
#:    prepare basic environment variables and do the shell specific tasks
#:  - in case of start as a command, open a shell (zsh or bash) and push this file
#:    as a resource
#: Main task is to run interactive shell session with this file as init resource
#: and the $CLE_RC variable must contain full path to the file
dbg_echo "startup case: '$ZSH_NAME$BASH:$0'"
case $ZSH_NAME$BASH:$0 in
*bash:*) # bash session resource
	dbg_echo sourcing to BASH
	CLE_RC=$BASH_SOURCE
	;;
*zsh:*zsh) # zsh session resource (started AS TEMPORARY .zshrc)
	dbg_echo sourcing to ZSH - from command
	# we know value of CLE_RC
	unset ZDOTDIR
	;;
*zsh:*/rc*) # started FROM .zshrc
	dbg_echo sourcing to ZSH - from .zshrc
	CLE_RC=$0
	;;
*:/*/rc*) # executed as a command
	#: code in this section must be strictly POSIX compatible with /bin/sh
	#: Now we're looking for suitable shell: zsh first, fallback to bash
	dbg_echo executing as script, looking for shell
	export CLE_RC=$(cd `dirname $0`;pwd;)/$(basename $0) # full path to this file
	ZS=`which zsh 2>/dev/null` # check zsh
	#: process command line options
	while [ $1 ]; do
		case $1 in
		-b)	ZS= ;;	# force bash
		-m)	CLE_MOTD=`uptime`
			export CLE_MOTD;;
		*)	echo "$0: unknown option '$1'"; exit 1;;
		esac
		shift
	done
	if [ $ZS ]; then
		dbg_echo foound: $ZS
		#: prepare startup environment in zsh way
		export ZDOTDIR=/tmp/$USER
		mkdir -p $ZDOTDIR
		ln -sf $CLE_RC $ZDOTDIR/.zshrc
		exec zsh
	elif which bash >/dev/null 2>&1; then
		dbg_echo found: `which bash`
		exec bash --rcfile $0
	else
		echo "CLE needs bash or zsh. Giving up..."
		exit 1
	fi
	;;
*:*zclerc*)	# first run!
	#: code in this section must be strictly POSIX compatible with /bin/sh
	dbg_echo First run
	RD=$HOME/.zcle-$USER
	export CLE_1=$RD/rc1
	mkdir -p $RD
	cp $0 $CLE_1
	chmod 755 $CLE_1
	exec $CLE_1 "$@"
	;;
*)	echo something unknown;;
esac

#: Reaching this point means that the script is running as a resource
#: to the interactive session. Further code must be bash & zsh compatible!

dbg_echo ---------------
dbg_echo Resource starts
dbg_echo ---------------


# boldprint
printb () { printf "$_CL$*$_CN\n";}

# execute script and log its filename into CLE_EXE
# also ensure the script will be executed only once
_clexe () {
	[ -f "$1" ] || return 1
	[[ $CLE_EXE =~ :$1[:$] ]] && return
	CLE_EXE=$CLE_EXE:$1
	dbg_echo _clexe $1
	source $1
}
CLE_EXE=$CLE_RC

# color table
#: initialize $_C* variables with terminal compatible escape sequences
#: following are basic ones:
_CN=`tput sgr0`
_CL=`tput bold`
_CU=`tput smul`;_Cu=`tput rmul`
_CD=`tput dim`
_CV=`tput rev`


# CLE_RC can be relative path, make it full
CLE_RD=$(cd `dirname $CLE_RC`;pwd;)
CLE_RC=$CLE_RD/`basename $CLE_RC`
dbg_var CLE_RC
dbg_var CLE_RD

# who I am
#: determine username that will be inherited over the all
#: subsquent sessions initiated with lssh and su* wrappers
#: the regexp extracts username from following patterns:
#: - /any/folder/.cle-username/rcfile
#: - /any/folder/.config/cle-username/rcfile
#: important is the dot (hidden folder), word 'cle' with dash
_N=`sed -n 's;.*cle-\(.*\)/.*;\1;p' <<<$CLE_RC`
export CLE_USER=${CLE_USER:-${_N:-$USER}}
dbg_var CLE_USER

# short hostname: remove domain, keep subdomains
CLE_SHN=`hostname|sed 's;\.[^.]*\.[^.]*$;;'`
CLE_IP=`cut -d' ' -f3 <<<$SSH_CONNECTION`

# where in the deep space CLE grows
CLE_SRC=https://raw.githubusercontent.com/micharbet/CLE
CLE_VER=`sed -n 's/^#\* version: //p' $CLE_RC`
CLE_REL=`sed 's/.*(\(.*\)).*/\1/' <<<$CLE_VER`
CLE_VER="$CLE_VER debug"
CLE_SH=`basename $BASH$ZSH_NAME`

# find writable folder
#: there can be real situation where a remote account is restricted and have no
#: home folder. In such case CLE can be started from /tmp. Also, after su*
#: wrapper the folder containing main resource file can be and usually will be
#: in different place than current home.
#: Simply to say, this sequence ensures customized configuration for every
#: account accessed with CLE.
[ -w $HOME ] || { HOME=/tmp/$USER; echo Temporary home: $HOME; }
CLE_D=$HOME/`sed 's:/.*/\(\..*\)/.*:\1:' <<<$CLE_RC`
mkdir -m 755 -p $CLE_D

# config, tweak, etc...
CLE_CF=$CLE_D/cf
CLE_AL=$CLE_D/al
CLE_WS=`sed 's:.*/rc1*::' <<<$CLE_RC`
CLE_TW=$CLE_RD/tw$CLE_WS
CLE_ALW=$CLE_RD/al$CLE_WS


# print MOTD + more
if [ "$CLE_MOTD" ]; then
	[ -f /etc/motd ] && cat /etc/motd
	printf "\n$CLE_MOTD"
	printb "\n CLE/$CLE_SH $CLE_VER\n"
	unset CLE_MOTD
fi

## ** cd command additions **
## `.. ...`     - up one or two levels
## `-`  (dash)  - cd to recent dir
- () { cd -;}
.. () { cd ..;}
... () { cd ../..;}

#: Following are su* wrappers of different kinds including kerberos
#: version 'ksu'. They are basically simple, you see. Environment is not
#: packed and transferred when using them. Instead the original files from
#: user's home folder are used.
## `lsudo [user]`      - sudo wrapper; root is the default account
lsudo () (
        sudo -i -u ${1:-root} $CLE_RC
)

## `lsu [user]`        - su wrapper
#: known issue - on debian systems controlling terminal is detached in case 
#: a command ($CLE_RC) is specified, use 'lsudo' instead
lsu () (
        S=
        [[ $OSTYPE =~ [Ll]inux ]] && S="-s /bin/sh"
        eval su -l $S -c $CLE_RC ${1:-root}
)

# heh, my stuff here!
_clexe $HOME/.cle-local
_clexe ~mich/.cle-mich/al

# zsh doesn't know '\n' as escape sequence
[ $ZSH_NAME ] && NL=$'\n' || NL='\n'
PS1="$NL(CLE/$CLE_SH $$ $CLE_USER->$USERNAME) $PS1"

cle () {
case $1 in
env)
	set |sed -n "s/^\(CLE_.*\)=\(.*\)/$_CL \1 $_CN \t\2/p"
	;;
*)
	echo nothing else here...
	;;
esac
}

#: final cleanup
unset _N
