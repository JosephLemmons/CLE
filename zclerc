#!/bin/sh
##
## ** CLE : Command Live Environment **
##
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* version: 2019-01-00 (Zodiac)
#* license: GNU GPL v2
#* Copyright (C) 2016-2019 by Michael Arbet

## WARNING!
## This code is in super early development stage.
## Do not use, otherwise a puppy or kitten may die!

# Debugging helpers							# dbg
dbg_echo () { [ $CLE_DEBUG ] && echo "$*" >/dev/tty; }			# dbg
dbg_var () (								# dbg
	[ $ZSH_NAME ] && V=${(P)1} || V=${!1}				# dbg
	[ $CLE_DEBUG ] && printf "%-16s = %s\n" $1 "$V" >/dev/tty	# dbg
)									# dbg
#: ^^^ This was first bit of zsh/bash compatible code			# dbg
[ -f $HOME/CLEDEBUG ] && { CLE_DEBUG=1; }				# dbg
#CLE_DEBUG=1	# force debugging on or comment this line		# dbg
dbg_echo; dbg_echo CLE pid:$$ DEBUG ON;					# dbg


# Startup sequence
#: First check how is this script executed
#:  - in case of a shell resource, this will be interactive session,
#:    prepare basic environment variables and do the shell specific tasks
#:  - in case of start as a command, open a shell (zsh or bash) and push this file
#:    as a resource
#: Then find out suitable shell and use it to run interactive shell session with
#: this file as init resource. The $CLE_RC variable must contain full path!
dbg_echo "startup case: '$ZSH_NAME$BASH:$0'"
case $ZSH_NAME$BASH:$0 in
*bash:*) # bash session resource
	dbg_echo sourcing to BASH
	CLE_RC=$BASH_SOURCE
	;;
*zsh:*zsh) # zsh session resource (started AS TEMPORARY .zshrc)
	dbg_echo sourcing to ZSH - from command
	# we know value of CLE_RC
	unset ZDOTDIR
	;;
*zsh:*/rc*) # started FROM .zshrc
	dbg_echo sourcing to ZSH - from .zshrc
	CLE_RC=$0
	;;
*:/*/rc*) # executed as a command
	#: code in this section must be strictly POSIX compatible with /bin/sh
	#: Now we're looking for suitable shell: zsh first, fallback to bash
	dbg_echo executing as script, looking for shell
	export CLE_RC=$(cd `dirname $0`;pwd;)/$(basename $0) # full path to this file
	ZS=`which zsh 2>/dev/null` # check zsh
	#: process command line options
	while [ $1 ]; do
		case $1 in
		-b)	ZS= 	# force bash
			export CLE_ARG='-b'
			;;
		-m)	CLE_MOTD=`uptime`
			export CLE_MOTD
			;;
		*)	echo "$0: unknown option '$1'"; exit 1;;
		esac
		shift
	done
	if [ $ZS ]; then
		dbg_echo foound: $ZS
		#: prepare startup environment in zsh way
		export ZDOTDIR=/tmp/$USER
		mkdir -p $ZDOTDIR
		ln -sf $CLE_RC $ZDOTDIR/.zshrc
		exec zsh
	elif which bash >/dev/null 2>&1; then
		dbg_echo found: `which bash`
		exec bash --rcfile $0
	else
		echo "CLE needs bash or zsh. Giving up..."
		exit 1
	fi
	;;
*:*zclerc*)	# first run!
	#: code in this section must be strictly POSIX compatible with /bin/sh
	dbg_echo First run
	RD=$HOME/.zcle-$USER
	export CLE_1=$0
	mkdir -p $RD
	cp $0 $RD/rc1
	chmod 755 $RD/rc1
	exec $RD/rc1 "$@"
	;;
*)	echo something unknown;;
esac

#: Reaching this point means that the script is running as a resource
#: to the interactive session. Further code must be bash & zsh compatible!
dbg_echo ---------------
dbg_echo Resource starts
dbg_echo ---------------

# boldprint
printb () { printf "$_CL$*$_CN\n";}

# simple question
ask () {
	local PR="$_CL$* (y/N) $_CN"
	[ $ZSH_NAME ] && read -ks "?$PR" || read -n 1 -s -p "$PR"
	echo ${REPLY:=n}
	[ "$REPLY" = "y" ]
}

_banner () {
cat <<EOT

   ___| |     ____|  Command Live Environment activated
  |     |     __|    ...bit of life to the command line
  |     |     |      Learn more:$_CL cle help$_CN and$_CL cle doc$_CN
 \____|_____|_____|  Uncover the magic:$_CL less $CLE_RC$_CN

EOT
}


# execute script and log its filename into CLE_EXE
# also ensure the script will be executed only once
_clexe () {
	[ -f "$1" ] || return 1
	[[ $CLE_EXE =~ :$1[:$] ]] && return
	CLE_EXE=$CLE_EXE:$1
	dbg_echo _clexe $1
	source $1
}
CLE_EXE=$CLE_RC

# color table
#: initialize $_C* variables with terminal compatible escape sequences
#: following are basic ones:
_CN=`tput sgr0`
_CL=`tput bold`
_CU=`tput smul`;_Cu=`tput rmul`
_CD=`tput dim`
_CV=`tput rev`
#: The loop creates table of color codes r, g, b...
#: lower case is for dim variant, upper case stands for bright
#: try e.g 'echo $_Cg green $_CY bright yellow'
_I=0; for _N in k r g y b m c w; do
	_C=`tput setaf $_I`
	declare _C$_N=$_CN$_C
	declare _C$(tr a-z A-Z <<<$_N)=$_CL$_C
	((_I+=1))
done
#: and... special color code for error highlight in prompt
_Ce=`tput setab 1;tput setaf 7` # err highlight




# CLE_RC can be relative path, make it full
CLE_RD=$(cd `dirname $CLE_RC`;pwd;)
CLE_RC=$CLE_RD/`basename $CLE_RC`
dbg_var CLE_RC
dbg_var CLE_RD

# who I am
#: determine username that will be inherited over the all
#: subsquent sessions initiated with lssh and su* wrappers
#: the regexp extracts username from following patterns:
#: - /any/folder/.cle-username/rcfile
#: - /any/folder/.config/cle-username/rcfile
#: important is the dot (hidden folder), word 'cle' with dash
_N=`sed -n 's;.*cle-\(.*\)/.*;\1;p' <<<$CLE_RC`
export CLE_USER=${CLE_USER:-${_N:-$USER}}
dbg_var CLE_USER

# short hostname: remove domain, keep subdomains
CLE_SHN=`hostname|sed 's;\.[^.]*\.[^.]*$;;'`
CLE_IP=`cut -d' ' -f3 <<<$SSH_CONNECTION`

# where in the deep space CLE grows
CLE_SRC=https://raw.githubusercontent.com/micharbet/CLE
CLE_VER=`sed -n 's/^#\* version: //p' $CLE_RC`
CLE_REL=`sed 's/.*(\(.*\)).*/\1/' <<<$CLE_VER`
CLE_VER="$CLE_VER debug"
CLE_SH=`basename $BASH$ZSH_NAME`

# find writable folder
#: there can be real situation where a remote account is restricted and have no
#: home folder. In such case CLE can be started from /tmp. Also, after su*
#: wrapper the folder containing main resource file can be and usually will be
#: in different place than current home.
#: Simply to say, this sequence ensures customized configuration for every
#: account accessed with CLE.
[ -w $HOME ] || { HOME=/tmp/$USER; echo Temporary home: $HOME; }
CLE_D=$HOME/`sed 's:/.*/\(\..*\)/.*:\1:' <<<$CLE_RC`
mkdir -m 755 -p $CLE_D

# config, tweak, etc...
CLE_CF=$CLE_D/cf
CLE_AL=$CLE_D/al
_N=`sed 's:.*/rc1*::' <<<$CLE_RC` # workstation name
CLE_WS=${_N/-/}
CLE_TW=$CLE_RD/tw$_N
CLE_ALW=$CLE_RD/al$_N

# Use alias built-ins
#: alias & unalias must be available in their natural form now
#: and will be redefined at the end of resource
unset -f alias unalias 2>/dev/null

#: Run profile files
#: Things in /etc/profile.d can override some settings.
#: E.g. there might be vte.sh defining own PROMPT_COMMAND and this completely
#: breaks rich history.
_clexe /etc/profile
_clexe $HOME/.${CLE_SH}rc

# print MOTD + more
if [ "$CLE_MOTD" ]; then
	[ -f /etc/motd ] && cat /etc/motd
	printf "\n$CLE_MOTD"
	printb "\n CLE/$CLE_SH $CLE_VER\n"
	unset CLE_MOTD
fi

# Alias works
# first load aliases inherited from CLE workstation
#: On workstation: load aliases later
#: On live sessions: read inherited aliases first, allow redefining locally
[ $CLE_AL != $CLE_ALW ] && _clexe $CLE_ALW

# colorize LS
case $OSTYPE in
linux*)		alias ls='ls --color=auto';;
darwin*)	export CLICOLOR=1; export LSCOLORS=ExGxBxDxCxEgEdxbxgxcxd;;
FreeBSD*)       alias ls='ls -G "$@"';;
*)		alias ls='ls -F';; # at least some file type indication
esac

# colorized GREP except on busybox
#: busybox identified by symlinked 'grep' file
if [ -L `command which grep` ];then
	#: Fedora defines this mess :(
	unalias grep egrep fgrep xzgrep xzegrep xzfgrep zgrep zegrep zfgrep
else
	alias grep='grep --color=auto'
fi

# Remove alias 'which' if there is no version supporting extended options
#: This weird construction ensures that the 'which' will work even in case
#: there's an alias containing extended options inherited from such system
#: to the one with simpler 'which' E.g. Fedora supports option --read-alias
#: but Debian, and BSD do not have this version of 'which' command.
{ alias|command which -i which || unalias which; } >/dev/null 2>&1

## ** cd command enhancements **
## `.. ...`     - up one or two levels
## `-`  (dash)  - cd to recent dir
- () { cd -;}
.. () { cd ..;}
... () { cd ../..;}
## `xx` & `cx`   - bookmark $PWD & use later
xx () { _XX=$PWD; echo path bookmark: $_XX; }
cx () { cd $_XX; }

##
## ** Alias management **
aa () {
	local AED=$CLE_AL.ed
	local Z=${ZSH_NAME:+-L}
	case "$1" in
	"")	## `aa`         - show aliases
		#: also make the output nicer and more easy to read
		builtin alias $Z|sed "s/^alias \([^=]*\)=\(.*\)/$_CL\1$_CN\t\2/";;
	-s)	## `aa -s`      - save aliases
		builtin alias $Z >$CLE_AL;;
	-e)	## `aa -e`      - edit aliases
		builtin alias $Z >$AED
		vi $AED
		[ $ZSH_NAME ] && builtin unalias -m '*' || builtin unalias -a
		. $AED;;
	*=*)	## `aa a='b'`   - create new alias and save
		builtin alias "$*"
		aa -s;;
	*)	builtin alias "$*";;
	esac
}

##
## ** Live session wrappers **

#: Following are su* wrappers of different kinds including kerberos
#: version 'ksu'. They are basically simple, you see. Environment is not
#: packed and transferred when using them. Instead the original files from
#: user's home folder are used.
## `lsudo [user]`      - sudo wrapper; root is the default account
lsudo () (
        sudo -i -u ${1:-root} $CLE_RC $CLE_ARG
)

## `lsu [user]`        - su wrapper
#: known issue - on debian systems controlling terminal is detached in case 
#: a command ($CLE_RC) is specified, use 'lsudo' instead
lsu () (
        S=
        [[ $OSTYPE =~ [Ll]inux ]] && S="-s /bin/sh"
        eval su $S -c \"$CLE_RC $CLE_ARG\" -l ${1:-root}
)

# heh, my stuff here!
_clexe $HOME/.cle-local
_clexe $CLE_AL

# just a simple prompt for now
# zsh doesn't know '\n' as escape sequence
[ $ZSH_NAME ] && NL=$'\n' || NL='\n'
PS1="$NL(CLE/$CLE_SH $$ $CLE_USER->$USER) $PS1"


# redefine alias builtins
#: those definitions must be here, only after config and tweaks not to mess
#: with builtin shell functions during startup. This also speeds up the thing
alias () {
	if [ -n "$1" ]; then
		aa "$@"
	else
		builtin alias
	fi
}

unalias () {
	[ "$1" = -a ] && cp $CLE_AL $CLE_AL.bk  # BASH only!
	builtin unalias "$@"
	aa -s
}

# check manual start
[ $CLE_1 ] && cat <<EOT
 It seems you started CLE running '$CLE_1' from command line
 Since this is the first run, consider setup in your profile.
 Run following command to hook CLE into your $HOME/.${CLE_SH}rc:
$_CL    cle deploy
EOT


##
## ** CLE command & control **
cle () {
case $1 in
env)
	set |sed -n "s/^\(CLE_.*\)=\(.*\)/$_CL \1 $_CN \t\2/p"
	;;
"")
	_banner
	sed -n 's/^#\*\(.*\)/\1/p' $CLE_RC
	;;
*)
	echo unimplemented: cle $C;
	#echo check cle help;
	return 1
	;;

esac
}

#: final cleanup
unset _N
