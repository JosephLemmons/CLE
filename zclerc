#!/bin/sh
##
## ** CLE : Command Live Environment **
##
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* version: 2019-01-00 (Zodiac)
#* license: GNU GPL v2
#* Copyright (C) 2016-2019 by Michael Arbet

## ** WARNING! **
## This code is in super early development stage.
## Do not use, otherwise a puppy or kitten may die!
##

#:------------------------------------------------------------:#

# Debugging helpers							# dbg
dbg_echo () { [ $CLE_DEBUG ] && echo "$*" >/dev/tty; }			# dbg
dbg_var () (								# dbg
	eval "V=\$$1"							# dbg
	[ $CLE_DEBUG ] && printf "%-16s = %q\n" $1 "$V" >/dev/tty	# dbg
)									# dbg
#: ^^^ This was first bit of zsh/bash compatible code			# dbg
[ -f $HOME/CLEDEBUG ] && { CLE_DEBUG=1; }				# dbg
dbg_echo; dbg_echo CLE pid:$$ DEBUG ON;					# dbg

#:------------------------------------------------------------:#

# Startup sequence
#: First check how is this script executed
#:  - in case of a shell resource, this will be interactive session,
#:    prepare basic environment variables and do the shell specific tasks
#:  - in case of start as a command, open a shell (zsh or bash) and push this file
#:    as a resource
#: Then find out suitable shell and use it to run interactive shell session with
#: this file as init resource. The $CLE_RC variable must contain full path!
dbg_echo "startup case: '$ZSH_NAME$BASH:$0'"
case $ZSH_NAME$BASH:$0 in
*bash:*) # bash session resource
	dbg_echo sourcing to BASH
	CLE_RC=$BASH_SOURCE
	;;
*zsh:*zsh) # zsh session resource (started AS TEMPORARY .zshrc)
	dbg_echo sourcing to ZSH - from command
	# we know value of CLE_RC
	unset ZDOTDIR
	;;
*zsh:*/rc*) # started FROM .zshrc
	dbg_echo sourcing to ZSH - from .zshrc
	CLE_RC=$0
	;;
*:/*/rc*) # executed as a command
	#: code in this section must be strictly POSIX compatible with /bin/sh
	#: Now we're looking for suitable shell: zsh first, fallback to bash
	dbg_echo executing as script, looking for shell
	export CLE_RC=$(cd `dirname $0`;pwd;)/$(basename $0) # full path to this file
	ZS=`which zsh 2>/dev/null` # check zsh
	#: process command line options
	while [ $1 ]; do
		case $1 in
		-b)	ZS= 	# force bash
			export CLE_ARG='-b'
			;;
		-m)	CLE_MOTD=`uptime`
			export CLE_MOTD
			;;
		*)	echo "$0: unknown option '$1'"; exit 1;;
		esac
		shift
	done
	if [ $ZS ]; then
		dbg_echo found: $ZS
		#: prepare startup environment in zsh way
		export ZDOTDIR=/tmp/$USER
		mkdir -p $ZDOTDIR
		ln -sf $CLE_RC $ZDOTDIR/.zshrc
		exec zsh
	elif which bash >/dev/null 2>&1; then
		dbg_echo found: `which bash`
		exec bash --rcfile $0
	else
		echo "CLE needs bash or zsh. Giving up..."
		exit 1
	fi
	;;
*:*zclerc*)	# first run!
	#: code in this section must be strictly POSIX compatible with /bin/sh
	dbg_echo First run
	RD=$HOME/.zcle-$USER
	export CLE_1=$0
	mkdir -p $RD
	cp $0 $RD/rc1
	chmod 755 $RD/rc1
	exec $RD/rc1 "$@"
	;;
*)	echo something unknown;;
esac

#: Reaching this point means that the script is running as a resource
#: to the interactive session. Further code must be bash & zsh compatible!
dbg_echo ---------------
dbg_echo Resource starts
dbg_echo ---------------

#:------------------------------------------------------------:#
# Variables init

# CLE_RC can be relative path, make it full
CLE_RD=$(cd `dirname $CLE_RC`;pwd;)
CLE_RC=$CLE_RD/`basename $CLE_RC`
dbg_var CLE_RC
dbg_var CLE_RD

# who I am
#: determine username that will be inherited over the all
#: subsquent sessions initiated with lssh and su* wrappers
#: the regexp extracts username from following patterns:
#: - /any/folder/.cle-username/rcfile
#: - /any/folder/.config/cle-username/rcfile
#: important is the dot (hidden folder), word 'cle' with dash
_N=`sed -n 's;.*cle-\(.*\)/.*;\1;p' <<<$CLE_RC`
export CLE_USER=${CLE_USER:-${_N:-$USER}}
dbg_var CLE_USER

# FQDN hack
#: `hostname -f` in some cases returns domain part only, without hostname!
#: Use the longer string. Also try `hostname' in case -f is't accepted (BSD) 
CLE_FHN=`hostname -f 2>/dev/null || hostname`
[ ${#CLE_FHN} -lt ${#HOST} ] && CLE_FHN=$HOST
CLE_IP=`cut -d' ' -f3 <<<$SSH_CONNECTION`

# where in the deep space CLE grows
CLE_SRC=https://raw.githubusercontent.com/micharbet/CLE
CLE_VER=`sed -n 's/^#\* version: //p' $CLE_RC`
CLE_REL=`sed 's/.*(\(.*\)).*/\1/' <<<$CLE_VER`
CLE_VER="$CLE_VER debug"

# current shell and shell prefix
CLE_SH=`basename $BASH$ZSH_NAME`
CLE_SP='B'; [ $ZSH_NAME ] && CLE_SP=Z

# find writable folder
#: there can be real situation where a remote account is restricted and have no
#: home folder. In such case CLE can be started from /tmp. Also, after su*
#: wrapper the folder containing main resource file can be and usually will be
#: in different place than current home.
#: Simply to say, this sequence ensures customized configuration for every
#: account accessed with CLE.
[ -w $HOME ] || { HOME=/tmp/$USER; echo Temporary home: $HOME; }
CLE_D=$HOME/`sed 's:/.*/\(\..*\)/.*:\1:' <<<$CLE_RC`
mkdir -m 755 -p $CLE_D

# config, tweak, etc...
CLE_CF=$CLE_D/cf
CLE_AL=$CLE_D/al
_N=`sed 's:.*/rc1*::' <<<$CLE_RC` # workstation name
CLE_WS=${_N/-/}
CLE_TW=$CLE_RD/tw$_N
CLE_ALW=$CLE_RD/al$_N
CLE_ENV=$CLE_RD/env$_N
CLE_TTY=`tty|tr -d '/dev'`

#:------------------------------------------------------------:#
# Internal functions

_clebnr () {
cat <<EOT

   ___| |     ____|  Command Live Environment activated
  |     |     __|    ...bit of life to the command line
  |     |     |      Learn more:$_CL cle help$_CN and$_CL cle doc$_CN
 \____|_____|_____|  Uncover the magic:$_CL less $CLE_RC$_CN

EOT
}

# boldprint
printb () { printf "$_CL$*$_CN\n";}

# simple question
ask () {
	local PR="$_CL$* (y/N) $_CN"
	[ $ZSH_NAME ] && read -ks "?$PR" || read -n 1 -s -p "$PR"
	echo ${REPLY:=n}
	[ "$REPLY" = "y" ]
}

# execute script and log its filename into CLE_EXE
# also ensure the script will be executed only once
_clexe () {
	[ -f "$1" ] || return 1
	[[ $CLE_EXE =~ :$1[:$] ]] && return
	CLE_EXE=$CLE_EXE:$1
	dbg_echo _clexe $1
	source $1
}
CLE_EXE=$CLE_RC

# Create color table
#: initialize $_C* variables with terminal compatible escape sequences
#: following are basic ones:
_cletable () {
	_CN=`tput sgr0`
	_CL=`tput bold`
	_CU=`tput smul`;_Cu=`tput rmul`
	_CD=`tput dim`
	_CV=`tput rev`
	#: The loop creates table of color codes r, g, b...
	#: lower case is for dim variant, upper case stands for bright
	#: try e.g 'echo $_Cg green $_CY bright yellow'
	_I=0; for _N in k r g y b m c w; do
		_C=`tput setaf $_I`
		declare -g _C$_N=$_CN$_C
		declare -g _C$(tr a-z A-Z <<<$_N)=$_CL$_C
		((_I+=1))
	done
	#: and... special color code for error highlight in prompt
	_Ce=`tput setab 1;tput setaf 7` # err highlight
}

# set prompt colors
_cleclr () {
	local C I CI
	case "$1" in
	red)    C=RrR;;
	green)  C=GgG;;
	yellow) C=YyY;;
	blue)   C=BbB;;
	cyan)   C=CcC;;
	magenta) C=MmM;;
	white|grey|gray) C=NwW;;
	tricolora) C=RBW;;
	marley) C=RYG;; # Bob Marley style :-) have a smoke and imagine...
	???)    C=$1;; # any 3 colors
	*)      # print help on colors
		printb "Unknown color '$1' Select predefined scheme:"
		declare -f _cleclr|sed -n 's/[ \t]*(*\(\<[a-z |]*\)).*/  \1/p'
		echo Alternatively create your own 3-letter combo using rgbcmykw/RGBCMYKW
		echo E.g. $_CL cle color rgB
		return 1
	esac
	# decode colors and prompt strings
	C=K$C
	for I in {0..3};do
		eval "CI=\$_C${C:$I:1}"
		[ -z "$CI" ] && printb "Wrong color code '${C:$I:1}' in $1" && CI=$_CN
		eval "_C$I=\$CI"
	done
}

# CLE prompt escapes
#: library of enhanced prompt escape codes introduced with ^ sign
#:  bash uses backslash while zsh percent sign for their prompt escapes
_clesc () (
	# bash/zsh specific sequences
	if [ $ZSH_NAME ]; then
		SHESC='-e "s/[\^]n/\$_PN/g"
		 -e "s/\^u/%n/g"
		 -e "s/\^w/%3~/g"
		 -e "s/\^t/%*/g"
		 -e "s/\^[$%#]/%#/g"
		'
	else
		SHESC='-e "s/\^n/\\\\n/g"
		 -e "s/\^u/\\\\u/g"
		 -e "s/\^w/\\\\w/g"
		 -e "s/\^t/\\\\A/g"
		 -e "s/\^[$%#]/\\\\\$/g"
		'
	fi
	EXTESC="
	 -e 's/\^i/\$CLE_IP/g'
	 -e 's/\^h/\$CLE_SHN/g'
	 -e 's/\^H/\$CLE_FHN/g'
	 -e 's/\^U/\$CLE_USER/g'
	 -e 's/\^e/\\$_PE\$_CE\\$_Pe\[\$_E\]\\$_PE\$_CN\$_C0\\$_Pe/g'
	 -e 's/\^c\(.\)/\\$_PE\\\$_C\1\\$_Pe/g'
	 -e 's/\^v\([[:alnum:]]*\)/\1=\$\1/g'
	 -e 's/\^\^/\^/g'
	"

	#: compose substitute command, remove unwanted characters
	SUBS=`tr -d '\n\t' <<<$SHESC$EXTESC`
	eval sed "$SUBS" <<<"$*"
)

# create prompt string
_cleps () {
	local I
	# override prompt strings with configured values
	#: use different variables for bash/zsh, eg. CLE_PB1 vs CLE_PZ1
	for I in 0 1 2 3; do
		eval "CLE_P$I=\${CLE_P$CLE_SP$I:-\$CLE_P$I}"
	done
	[ "$CLE_PT" ] && PS1="$_PE\${_CT}$(_clesc $CLE_PT)\${_Ct}$_Pe" || PS1=''
	PS1=$PS1`_clesc "^c0$CLE_P0 ^c1$CLE_P1 ^c2$CLE_P2 ^c3$CLE_P3 ^cN"`
}

# default prompt strings and colors
_cledefp () {
	# default prompt strings
	CLE_P0='^e ^t'
	CLE_P1='^u'
	CLE_P2='^h'
	CLE_P3='^w ^$'
	CLE_PT='$CLE_SH: ^u@^H'
	# default colors
	case "$USER-$CLE_WS" in
	root-)	_DEFC=red;;
	*-)	_DEFC=marley;;
	root-*)	_DEFC=RbB;;
	*-*)	_DEFC=blue;;
	esac
}

# save configuration
_clesave () (
	vars "CLE_CLR|CLE_PB.|CLE_PZ."
	date +"# CLE/$CLE_REL %Y-%m-%d %H:%M:%S"
) >$CLE_CF


# prompt callback function
#: As precmd function is executed *every* time you push enter key its code
#: should be as simple as possible. In best case all commands here should be
#: bash internals. Those don't invoke new processes and as such they are much
#: easier to system resources.
CLE_HIST=$HOME/.clehistory
precmd () {
	_E=$? # save return code
	local H N D T C
	unset IFS
	[ $ZSH_NAME ] && H=`fc -lt "$HISTTIMEFORMAT" -1` || H=`history 1`
	read -r N D T C <<<$H
	if [ "$_E$C" != "$_OLDC" -a -n "$_OLDC" ]; then
		echo "$D $T $CLE_USER-$CLE_SP$$ $_E $PWD $C" >>$CLE_HIST
	fi
	_OLDC=$_E$C
	# highlight error code
	[ $_E = 0 ] && _CE="" || _CE="$_Ce"
}

# Use alias built-ins for startup
#: alias & unalias must be available in their natural form now
#: and will be redefined at the end of resource
unset -f alias unalias 2>/dev/null

#: Run profile files
#: Things in /etc/profile.d can override some settings.
#: E.g. there might be vte.sh defining own PROMPT_COMMAND and this completely
#: breaks rich history.
_clexe /etc/profile
_clexe $HOME/.${CLE_SH}rc

# print MOTD + more
if [ "$CLE_MOTD" ]; then
	[ -f /etc/motd ] && cat /etc/motd
	printf "\n$CLE_MOTD"
	printb "\n CLE/$CLE_SH $CLE_VER\n"
	unset CLE_MOTD
fi

# Alias works
# first load aliases inherited from CLE workstation
#: On workstation: load aliases later
#: On live sessions: read inherited aliases first, allow redefining locally
[ $CLE_AL != $CLE_ALW ] && _clexe $CLE_ALW

# colorize LS
case $OSTYPE in
linux*)		alias ls='ls --color=auto';;
darwin*)	export CLICOLOR=1; export LSCOLORS=ExGxBxDxCxEgEdxbxgxcxd;;
FreeBSD*)       alias ls='ls -G "$@"';;
*)		alias ls='ls -F';; # at least some file type indication
esac

# colorized GREP except on busybox
#: busybox identified by symlinked 'grep' file
if [ -L `command which grep` ];then
	#: Fedora defines this mess :(
	unalias grep egrep fgrep xzgrep xzegrep xzfgrep zgrep zegrep zfgrep
else
	alias grep='grep --color=auto'
fi

# Remove alias 'which' if there is no version supporting extended options
#: This weird construction ensures that the 'which' will work even in case
#: there's an alias containing extended options inherited from such system
#: to the one with simpler 'which' E.g. Fedora supports option --read-alias
#: but Debian, and BSD do not have this version of 'which' command.
{ alias|command which -i which || unalias which; } >/dev/null 2>&1

## ** cd command enhancements **
## `.. ...`     - up one or two levels
## `-`  (dash)  - cd to recent dir
- () { cd -;}
.. () { cd ..;}
... () { cd ../..;}
## `xx` & `cx`   - bookmark $PWD & use later
xx () { _XX=$PWD; echo path bookmark: $_XX; }
cx () { cd $_XX; }

##
## ** Alias management **
aa () {
	local AED=$CLE_AL.ed
	local Z=${ZSH_NAME:+-L}
	case "$1" in
	"")	## `aa`         - show aliases
		#: also make the output nicer and more easy to read
		builtin alias $Z|sed "s/^alias \([^=]*\)=\(.*\)/$_CL\1$_CN\t\2/";;
	-s)	## `aa -s`      - save aliases
		builtin alias $Z >$CLE_AL;;
	-e)	## `aa -e`      - edit aliases
		builtin alias $Z >$AED
		vi $AED
		[ $ZSH_NAME ] && builtin unalias -m '*' || builtin unalias -a
		. $AED;;
	*=*)	## `aa a='b'`   - create new alias and save
		builtin alias "$*"
		aa -s;;
	*)	builtin alias "$*";;
	esac
}

##
## ** Not-just-internal tools **
## `vars 'regexp'`   - dump variables in reusable way, bash/zsh compatible
#: it was difficult to create this shot function and make it working
#: in both zsh and bash because:
#:  - in bash 'set' displays also functions - this is why there's 
#:    first awk command: "/.* \(\)/ {exit}"
#:  - zsh dereferences variable differently
#:  - zsh on debian doesn't quote escape strings and 'mawk' stops
#:    processing on special characters, gawk is required!
#: This function might be useful also as command thus named without underscore
vars () (
	set 2>/dev/null | awk -F= "/.* \(\)/{exit} /^($1)=/ {print \$1}" | while read N
	do
		eval "V=\$$N"
		printf %s=%q\\n $N "$V"
	done
)

## `mdfilter`        - markdown acsii highlighter
#: Highly sophisticated filter :-D
#: Just replaces special strings in markdown files and augments the output
#: with escape codes to highlight.
#: Not perfect, but it helps and is simple, isn't it?
mdfilter () {
	sed -e "s/^###\(.*\)/$_CL\1$_CN/"\
	 -e "s/^##\( *\)\(.*\)/\1$_CU$_CL\2$_CN/"\
	 -e "s/^#\( *\)\(.*\)/\1$_CL$_CV \2 $_CN/"\
	 -e "s/\*\*\(.*\)\*\*/$_CL\1$_CN/"\
	 -e "s/\<_\(.*\)_\>/$_CU\1$_Cu/g"\
	 -e "s/\`\`\`/$_CD~~~~~~~~~~~~~~~~~$_CN/"\
	 -e "s/\`\([^\`]*\)\`/$_Cg\1$_CN/g"
}


#:------------------------------------------------------------:#
##
## ** Live session wrappers **

# environment packer
#: grab *active* resource file, tweak file, pack it to tarball and store
#: into variable C64 as base64 encoded string.
#: Argument ($1) may contain additional suffix to filenames
#: Second outcome of _clepak is value in $RC - relative path to the resource
#: file that should be run on remote system (it may contain the suffix)
#: Note: configuration is not packed in order to ensure unique cf on all
#:  remote accounts.
#: Note 2: _clepak is defined with curly brackets {} to pass variables RC and C64
#:  On the other side lssh is defined with () ensuring execution in its own context
#:  where all new variables are local only to lssh (and _clepak)
#: Note 3: _clepak is fuction even if it is used only once and could be
#:  included directly into lssh. However, this allows to create any other
#:  remote access wrapper
_clepak () {
	#: anything up to first dotted folder is home for .cle folder
	vars "CLE_P.*|_C.|$CLE_VARS" >$CLE_ENV
	cd `sed 's:\(/.*\)/\..*:\1:' <<<$CLE_RC`
	RC=${CLE_RC/$PWD\//}
	TW=${CLE_TW/$PWD\//}
	AL=${CLE_ALW/$PWD\//}
	EN=${CLE_ENV/$PWD\//}
	if [ $1 ];then
		#: change names and copy files when adding suffix
		#: this happens when doing lssh (from CLE ws)
		RC=$RC$1; TW=$TW$1; AL=$AL$1; EN=$EN$1
		cp $CLE_RC $RC
		cp $CLE_TW $TW 2>/dev/null
		cp $CLE_AL $AL 2>/dev/null
		cp $CLE_ENV $EN
	fi
	RCS="$RC $TW $AL $EN"
	dbg_var PWD
	dbg_var RCS
	#:  I've never owned this computer, I had Atari 800XL :)
	C64=`eval tar chzf - $RCS 2>/dev/null | base64 | tr -d '\n\r '`
	#: 'eval' required due to zsh.
}

## `lssh [usr@]host`   - access remote system and take CLE along
lssh () (
	[ "$1" ] || { cle help lssh;return 1;}
	#: on CLE workstation, suffix to resource filename is added
	#: this 1. prevents overwriting on destination accounts
	#:  and 2. provides information about source of the session
	S= #: resource suffix is empty on remote sessions...
	[ $CLE_WS ] || S=-$CLE_FHN #: adding suffix when running on WS
	_clepak $S
	[ $CLE_DEBUG ] && echo -n $C64 |base64 -d|tar tzvf -
	command ssh -t $* "
		[ -w \$HOME ] && _H=\$HOME || _H=/tmp/\$USER
		[ $OSTYPE = darwin ] && _D=D || _D=d
		mkdir -m 755 -p \$_H; cd \$_H
		echo -n $C64|base64 -\$_D |tar xzf -;
		exec $RC -m $CLE_ARG"
)

#: Following are su* wrappers of different kinds including kerberos
#: version 'ksu'. They are basically simple, you see. Environment is not
#: packed and transferred when using them. Instead the original files from
#: user's home folder are used.
## `lsudo [user]`      - sudo wrapper; root is the default account
lsudo () (
	vars "CLE_P.*|_C.|$CLE_VARS" >$CLE_ENV
        sudo -i -u ${1:-root} $CLE_RC $CLE_ARG
)

## `lsu [user]`        - su wrapper
#: known issue - on debian systems controlling terminal is detached in case 
#: a command ($CLE_RC) is specified, use 'lsudo' instead
lsu () (
	vars "CLE_P.*|_C.|$CLE_VARS" >$CLE_ENV
        S=
        [[ $OSTYPE =~ [Ll]inux ]] && S="-s /bin/sh"
        eval su $S -c \"$CLE_RC $CLE_ARG\" -l ${1:-root}
)

## `lksu [user]`       - ksu wrapper
#: Kerberized version of 'su'
lksu () (
	vars "CLE_P.*|_C.|$CLE_VARS" >$CLE_ENV
        ksu ${1:-root} -a -c $CLE_RC
)

## `lscreen [name]`    - gnu screen wrapper, join your recent session or start new
## `lscreen -j [name]` - join other screen sessions, ev. search by name
#: GNU screen wrapper is here 1) because of there was no way to tell screen
#: program to start CLE on more than first window and, 2) to allow easily
#: join detached own session and/or join cooperative session with more
#: participants.
lscreen () (
	#: get name of the screen to search and join
	#: base of session name is $CLE_USER and this can be extended
	NM=$CLE_USER${1:+-$1}
	[ "$1" = -j ] && NM=${2:-.}
	#: list all screens with that name and find how many of them are there
	SCRS=`screen -ls|sed -n "/$NM/s/^[ \t]*\([0-9]*\.[^ \t]*\)[ \t]*.*/\1/p"`
	NS=`wc -w <<<$SCRS`
	if [ $NS = 0 ]; then
		[ "$1" = -j ] && echo "No screen to join" && return 1
		#: No session with given name found, prepare to start new session
		SCF=$CLE_D/screenrc
		SN=$CLE_TTY-CLE.$NM
#		_rhlog screen -S $SN
		_clescrc >$SCF
		screen -c $SCF -S $SN $CLE_RC
	else
		#: is there only one such session or more?
		if [ $NS = 1 ]; then SN=$SCRS
		else
			#: we found more screens with simiilar names, choose one!
			printb "${_CU}Current '$NM' sessions:"
			PS3="$_CL choose # to join: $_CN"
			select SN in $SCRS;do
				[ $SN ] && break
			done
		fi
#		_rhlog screen -x $SN
		#: send message to other screen, then join the session
		screen -S $SN -X echo "$CLE_USER joining"
		screen -x $SN
	fi
)

# screenrc generator
#: This generates nice configuration file with cool features:
#:  - always visible status line with list of windows, hostname and clock
#:  - feature to quickly switch using Ctrl+Left/Right Arrows
#:  - reads good old $HOME/.screenrc
#: Own screenrc file is necessary because otherwise it wouldn't start CLE in
#: subsequent windows created with 'C-a C-c' (note the bind commands, above
#: mentioned features are cool but this part is the important one)
_clescrc () {
cat <<-EOS
	source $HOME/.screenrc
	altscreen on
	autodetach on
	# enables shift-PgUp/PgDn
	termcapinfo xterm* ti@:te@
	# change window with ctrl-left/right
	bindkey "^[[1;5D" prev
	bindkey "^[[1;5C" next
	defscrollback 9000
	hardstatus alwayslastline
	hardstatus string '%{= Kk} %-w%{Wk}%n %t%{-}%+w %-=%{KG}$CLE_SHN%{KY} %c'
	bind c screen $CLE_RC
	bind ^c screen $CLE_RC
EOS
}


#:------------------------------------------------------------:#
# config, tweaks, env

_clexe $HOME/.cle-local
_clexe $CLE_AL
[ $CLE_USER != $USER -o -n "$CLE_WS" ] && _clexe $CLE_ENV #: read environment only on live session
_clexe $CLE_TW
# shorten hostname: by default remove domain, leave subdomains
# Eventually apply CLE_SRE as sed regexp for custom shortening
CLE_SHN=`eval sed "${CLE_SRE:-'s:\.[^.]*\.[^.]*$::'}" <<<$CLE_FHN`
_clexe $CLE_CF || _clebnr
[ $_CN ] || _cletable #: initialize color table only if necessary, don't waste cycles


# craft the prompt
_cledefp
_cleclr ${CLE_CLR:-$_DEFC}
unset _DEFC
PROMPT_COMMAND=precmd
PROMPT_DIRTRIM=3

# termnal specific
case $TERM in
linux)	 CLE_PT='';;	# no tits on console
screen*) CLE_PT='^u'
	_CT=$'\ek'; _Ct=$'\e\\';;
*)	_CT=$'\e]0;'; _Ct=$'\007';;
esac

# shell specific settings
if [ $ZSH_NAME ]; then
	setopt PROMPT_SUBST SH_WORD_SPLIT
	_PE='%{'; _Pe='%}'
	_PN=$'\n' # zsh doesn't know '\n' as escape sequence! WTF?
else
	shopt -s checkwinsize
	_PE='\['; _Pe='\]'
fi

_cleps

HISTCONTROL=ignoredups
HISTFILE=$HOME/.history-$CLE_USER
HISTTIMEFORMAT='%Y-%m-%d %T '

# redefine alias builtins
#: those definitions must be here, only after config and tweaks not to mess
#: with builtin shell functions during startup. This also speeds up the thing
alias () {
	if [ -n "$1" ]; then
		aa "$@"
	else
		builtin alias
	fi
}

unalias () {
	[ "$1" = -a ] && cp $CLE_AL $CLE_AL.bk  # BASH only!
	builtin unalias "$@"
	aa -s
}

# check manual start
[ $CLE_1 ] && cat <<EOT
 It seems you started CLE running '$CLE_1' from command line
 Since this is the first run, consider setup in your profile.
 Run following command to hook CLE into your $HOME/.${CLE_SH}rc:
$_CL    cle deploy
EOT


##
## ** CLE command & control **
cle () {
	local C I P
	case $1 in
	color)  ## `cle color COLOR` - set prompt color
		[ $2 ]  && _cleclr $2 && CLE_CLR=$2 && _clesave;;
	p?)	## `cle p0-p3 [str]` - show/define prompt parts
		I=${1:1:1}
		if [ "$2" ]; then
			shift
			P=CLE_P$CLE_SP$I   #: save to shell-corresponding variable
			eval "$P='$*'"
			_cleps;_clesave
		else
			P=CLE_P$I
			eval "echo $P=\'\$$P\'"
		fi;;
	title)	## `cle title off`   - turn off window title
		## `cle title [str]` - set title string
		[ "$2" = off ] && CLE_PT='' || CLE_PT=${2:-'$CLE_SH: ^u@^H'}
		_cleps;;
	reload) ## `cle reload`      - reload CLE
		for I in 0 1 2 3 T; do unset CLE_PB$I CLE_PZ$I; done
		unset CLE_EXE CLE_CLR
		. $CLE_RC
		echo CLE $CLE_VER;;
	reset)	## `cle reset`       - clear config and reload
		rm -f $CLE_CF
		cle reload;;
	env)	## `cle env`         - inspect variables
		set|awk -F= "/.* \(\)/{exit}  /^CLE.*=/ {printf \"$_CL%-12s$_CN%s\n\",\$1,\$2}";;
	cf)	## `cle cf [ed]`     - view/edit configuration
		[ "$2" = ed ] && vi $CLE_CF  && . $CLE_RC
		cat $CLE_CF 2>/dev/null || echo Default;;
	ls)	printb CLE_D: $CLE_D; ls -l $CLE_D; printb CLE_RD: $CLE_RD; ls -l $CLE_RD;;	# dbg
	exe)	echo $CLE_EXE|tr : \\n;;							# dbg
	debug)	[ "$2" = off ] && CLE_DEBUG='' || CLE_DEBUG=${2:-on}				# dbg
		dbg_var CLE_DEBUG ;;								# dbg
	help|-h|--help) ## `cle help [fnc]`  - show help
		# double hash denotes help content
		C=`ls "$CLE_D/cle-*" 2>/dev/null`
		awk -F# "/[\t ]## *\`*$2|^## *\`*$2/ { print \$3 }" ${CLE_EXE//:/ } $C | mdfilter | less -erFX;;
	"")
		_clebnr
		sed -n 's/^#\*\(.*\)/\1/p' $CLE_RC
		;;
	*)
		echo unimplemented: cle $C;
		echo check cle help;
		return 1
		;;
	esac
}

##
#: final cleanup
unset _N
