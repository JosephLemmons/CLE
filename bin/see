#!/bin/bash
#
## see: text stream highlighter
## ----------------------------
#* version: 2017-09-23
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: GNU GPL v2
#* Copyright (C) 2016-2017 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#

## see [-n] [-t nsec] [-f filename] [-a] word1 [word2] [word3]
##
## Parses the text through regular expressions (sed) and highlights
## up to three selected words. It filters either stdin or file
## on command line. As an addition red timestamps are printed every 
## minute, they can be turned off by setting the interval to zero.
## 

# defaults
SUPPRESS=""
TSTAMP=60
READER=""  # stdin will be used without '-f filename' argument
AND=""

# Colours
RST=`tput sgr0`
BLD=`tput bold`
RD=`tput setaf 1`; BR=$BLD$RD
GR=`tput setaf 2`; BG=$BLD$GR
YL=`tput setaf 3`; BY=$BLD$YL
CY=`tput setaf 6`; BC=$BLD$CY

# function printing regular red colored timestamps
tstamp () {
	[ $1 -eq 0 ] && return
	while true; do
		date "+$BR[%Y-%m-%d %T] -- ${INFILE:-STDIN}$RST"
		sleep $1
	done &
}

## Options:
while getopts "ant:f:" OPT
do
	case $OPT in
	t)	##   -t nsec  print red timestamps, default 60 seconds
		TSTAMP=$OPTARG
		;;
	f)	##   -f file  open filename instead of stdin
		INFILE=$OPTARG
		READER="tail -f $INFILE | "
		;;
	a)	##   -a       highlight when all words are found (AND operator, default is OR)
		##            note: AND will highight whole line not separated words
		AND=1
		;;
	n)	##   -n       suppress unmatched lines
		SUPPRESS=-n
		;;
	*) cle help ${BASH_SOURCE[0]}; return 1 ;;
	esac
done
shift $((OPTIND-1))

# Prepare search - replacement expressions up to three words
# Note: AND operator uses '@' as marker for counting matching words
#       thus the highlithing can be broken if lines begin with '@'
#       In that case it might worth to use different character.

case $# in
1)	RE="s/\\($1\\)/$BG\\1$RST/"g
	;;
2)	if [ -n "$AND" ]; then
		# count matching words, insert '@' as marker
		RE="/$1/s/\\(.*\\)/@\\1/"
		RE=$RE";/$2/s/\\(.*\\)/@\\1/"
		# highlight words, eventually whole line and remove markers
		RE=$RE";/^@@/s/\\($1\\|$2\\)/$BC\\1$RST$CY/g"
		RE=$RE";/^@@/s/\\(@@\\)\\(.*\\)/$CY\\2$RST/"
		RE=$RE";/^@/s/\\($1\\|$2\\)/$BC\\1$RST/g"
		RE=$RE";/^@/s/\\(@\\)\\(.*\\)/\\2/"
	else
		RE="s/\\($1\\)/$BG\\1$RST/"g
		RE=$RE";s/\\($2\\)/$BY\\1$RST/"g
	fi
	;;
3)	if [ -n "$AND" ]; then
		# count matching words, use '@' as marker
		RE="/$1/s/\\(.*\\)/@\\1/"
		RE=$RE";/$2/s/\\(.*\\)/@\\1/"
		RE=$RE";/$3/s/\\(.*\\)/@\\1/"
		# highlight words, eventually whole line and remove markers
		RE=$RE";/^@@@/s/\\($1\\|$2\\|$3\\)/$BC\\1$RST$CY/g"
		RE=$RE";/^@@@/s/\\(@@@\\)\\(.*\\)/$CY\\2$RST/"
		RE=$RE";/^@/s/\\($1\\|$2\\|$3\\)/$BC\\1$RST/g"
		RE=$RE";/^@/s/\\(@\\{1,3\\}\\)\\(.*\\)/\\2/"
	else
		RE="s/\\($1\\)/$BG\\1$RST/"g
		RE=$RE";s/\\($2\\)/$BY\\1$RST/"g
		RE=$RE";s/\\($3\\)/$BC\\1$RST/"g
	fi
	;;
*)
	hlp ${BASH_SOURCE[0]}
	exit;;
esac

tstamp $TSTAMP

# run and parse 
[ "$SUPPRESS" ] && RE=${RE}p
eval "$READER sed $SUPPRESS -e '$RE'"

