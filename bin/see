#!/bin/bash
#
## see: text stream highlighter
## ----------------------------
#* version: 2017-08-18
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: GNU GPL v2
#* Copyright (C) 2016-2017 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#

## see [-n] [-t nsec] [-f filename] [-a] word1 [word2] [word3]
##
## Parses the text through regular expressions (sed) and highlights
## up to three selected words. It filters either stdin or file
## on command line. As an addition red timestamps are printed every 
## minute, they can be turned off by setting the interval to zero.
## 

# defaults
SUPPRESS=""
TSTAMP=60
READER=""
AND=""

# Colours
RST=`tput sgr0`
BLD=`tput bold`
GRN=$BLD$(tput setaf 2)
YLL=$BLD$(tput setaf 3)
CYA=$BLD$(tput setaf 6)
RED=$BLD$(tput setaf 1)

## Options:
while getopts "ant:f:" OPT
do
	case $OPT in
	t)	##   -t nsec  print red timestamps, default 60 seconds
		TSTAMP=$OPTARG
		;;
	f)	##   -f file  open filename instead of stdin
		READER="tail -f $OPTARG |"
		;;
	a)	##   -a       highlight when all words are found (AND operator, default is OR)
		##            note: AND will highight whole line not separated words
		AND=1
		;;
	n)	##   -n       suppress unmatched lines
		SUPPRESS=-n
		;;
	*) cle help ${BASH_SOURCE[0]}; return 1 ;;
	esac
done
shift $((OPTIND-1))

# Prepare search - replacement expressions
# currently up to three words
case $# in
1)	RE1="-e 's/\\($1\\)/$GRN\\1$RST/'"
	[ "$SUPPRESS" ] && RE1=${REXP}p
	;;
2)	if [ -n "$AND" ]; then
		RE1="-e '/$1.*$2/s/\\(.*\\)/$CYA\\1$RST/'"
		RE2="-e '/$2.*$1/s/\\(.*\\)/$CYA\\1$RST/'"
	else
		RE2="-e '/$1/s/\\($1\\)/$GRN\\1$RST/'"
		RE1="-e '/$2/s/\\($2\\)/$YLL\\1$RST/'"
	fi
	[ "$SUPPRESS" ] && RE2=${RE2}p
	;;
3)	if [ -n "$AND" ]; then
		# count matching words, use '@' as marker
		RE1="-e '/$1/s/\\(.*\\)/@\\1/'"
		RE2="-e '/$2/s/\\(.*\\)/@\\1/'"
		RE3="-e '/$3/s/\\(.*\\)/@\\1/'"
		# remove marker and eventually highlight if there are 3
		RE3=$RE3" -e 's/\\(@@@\\)\\(.*\\)/$CYA\\2$RST/'"
		RE3=$RE3" -e 's/\\(@\\{1,3\\}\\)\\(.*\\)/\\2/'"
	else
		RE1="-e '/$1/s/\\($1\\)/$GRN\\1$RST/'"
		RE2="-e '/$2/s/\\($2\\)/$YLL\\1$RST/'"
		RE3="-e '/$3/s/\\($3\\)/$CYA\\1$RST/'"
	fi
	[ "$SUPPRESS" ] && RE3=${RE3}p
	;;
*)
	hlp ${BASH_SOURCE[0]}
	exit;;
esac

# prepare the filter to be run
RUN="$READER sed $SUPPRESS $RE1 $RE2 $RE3"
if [ $TSTAMP -gt 0 ]; then
	# loop in background prints timestamps, 
	bash -c "while true; do \
			date '+$RED[%d-%m-%Y %T]$RST'; \
			sleep $TSTAMP; \
		 done" &
	# trap ensures the loop will be terminated
	bash -c "trap 'kill $!' EXIT; $RUN"  
else
	bash -c "$RUN"
fi

