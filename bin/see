#!/bin/bash
#
## see: text stream highlighter
## ----------------------------
#* version: 2017-08-18
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: GNU GPL v2
#* Copyright (C) 2016-2017 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#

## see [-n] [-t nsec] [-f filename] [-a] word1 [word2] [word3]
##
## Parses the text through regular expressions (sed) and highlights
## up to three selected words. It filters either stdin or file
## on command line. As an addition red timestamps are printed every 
## minute, they can be turned off by setting the interval to zero.
## 

# defaults
SUPPRESS=""
TSTAMP=60
READER="cat"  # stdin will be used without '-f filename' argument
AND=""

# Colours
RST=`tput sgr0`
BLD=`tput bold`
GRN=$BLD$(tput setaf 2)
YLL=$BLD$(tput setaf 3)
CYA=$BLD$(tput setaf 6)
RED=$BLD$(tput setaf 1)

RST='_RST_'
BLD='_BLD_'
GRN='_GRN_'
YLL='_YLL_'
CYA='_CYA_'
RED='_RED_'

## Options:
while getopts "ant:f:" OPT
do
	case $OPT in
	t)	##   -t nsec  print red timestamps, default 60 seconds
		TSTAMP=$OPTARG
		;;
	f)	##   -f file  open filename instead of stdin
		INFILE=$OPTARG
		READER="tail -f $INFILE | "
		;;
	a)	##   -a       highlight when all words are found (AND operator, default is OR)
		##            note: AND will highight whole line not separated words
		AND=1
		;;
	n)	##   -n       suppress unmatched lines
		SUPPRESS=-n
		;;
	*) cle help ${BASH_SOURCE[0]}; return 1 ;;
	esac
done
shift $((OPTIND-1))

# Prepare search - replacement expressions
# currently up to three words
case $# in
1)	RE="s/\\($1\\)/$GRN\\1$RST/"
	[ "$SUPPRESS" ] && RE=${RE}p
	$READER | sed $SUPPRESS -e "$RE" &
	;;
2)	if [ -n "$AND" ]; then
		RE1="'/$1.*$2/s/\\(.*\\)/$CYA\\1$RST/'"
		RE2="'/$2.*$1/s/\\(.*\\)/$CYA\\1$RST/'"
	else
		RE1="s/\\($1\\)/$GRN\\1$RST/"
		RE2="s/\\($2\\)/$YLL\\1$RST/"
	fi
	[ "$SUPPRESS" ] && RE2=${RE2}p
	echo $SUPPRESS -e "$RE1;$RE2"
	$READER | sed $SUPPRESS -e "$RE1;$RE2" &
	;;
3)	if [ -n "$AND" ]; then
		# count matching words, use '@' as marker
		RE1="'/$1/s/\\(.*\\)/@\\1/'"
		RE2="'/$2/s/\\(.*\\)/@\\1/'"
		RE3="'/$3/s/\\(.*\\)/@\\1/'"
		# remove marker and eventually highlight if there are 3
		RE3=$RE3";'s/\\(@@@\\)\\(.*\\)/$CYA\\2$RST/'"
		RE3=$RE3";'s/\\(@\\{1,3\\}\\)\\(.*\\)/\\2/'"
	else
		RE1="'/$1/s/\\($1\\)/$GRN\\1$RST/'"
		RE2="'/$2/s/\\($2\\)/$YLL\\1$RST/'"
		RE3="'/$3/s/\\($3\\)/$CYA\\1$RST/'"
	fi
	RE="$RE1;$RE2;$RE3"
	[ "$SUPPRESS" ] && RE=${RE}p
	;;
*)
	hlp ${BASH_SOURCE[0]}
	exit;;
esac

# run and parse in tha background

# print timestamps (if required) in the foreground
if [ $TSTAMP -ne 0 ]; then

	while true; do 
		date "+$RED[%d-%m-%Y %T] -- ${INFILE:stdin}$RST";
		sleep $TSTAMP
	done
else
	wait
fi

