##
## mod-see: Text flow highlighter
## ------------------------------
#* version: 0.1.prd
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: GNU GPL v2
#* Copyright (C) 2016-2017 by Michael Arbet 
#
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#

## see [-n] [-t nsec] [-f filename] [-a] word1 [word2] [word3]
##
## Parses the text through regular expressions (sed) and highlights
## up to three selected words. It filters either stdin or file
## on command line. As an addition red timestamps are printed every 
## minute, they can be turned off by setting the interval to zero.
## 
see () {
	# defaults
	local SUPPRESS=""
	local TSTAMP=60
	local READER=""
	local AND=""
	local OPTIND # local scope is necessary in function
	             # this variable is used in getopts
	local RE1 RE2 RE3

	## Options:
	while getopts "ant:f:" OPT
	do
		case $OPT in
		t)	##   -t nsec  print red timestamps, default 60 seconds
			TSTAMP=$OPTARG
			;;
		f)	##   -f file  open filename instead of stdin
			READER="tail -f $OPTARG |"
			;;
		a)	##   -a       highlight when all words are found (AND operator, default is OR)
			##            note: AND will highight whole line not separated words
			AND=1
			;;
		n)	##   -n       suppress unmatched lines
			SUPPRESS=-n
			;;
		*) cle help ${BASH_SOURCE[0]}; return 1 ;;
		esac
	done
	shift $((OPTIND-1))

	# Prepare search - replacement expressions
	# currently up to three words
	case $# in
	1)	RE1="-e 's/\\($1\\)/$_TG\\1$_TN/'"
		[ "$SUPPRESS" ] && RE1=${REXP}p
		;;
	2)	if [ -n "$AND" ]; then
			#RE1="-e '/$1.*$2/s/\\($1\\)\\(.*\\)\\($2\\)/$_TB\\1$_TN\\2$_TW\\3$_TN/'"
			RE1="-e '/$1.*$2/s/\\(.*\\)/$_TB\\1$_TN/'"
			RE2="-e '/$2.*$1/s/\\(.*\\)/$_TB\\1$_TN/'"
		else
			RE2="-e '/$1/s/\\($1\\)/$_TG\\1$_TN/'"
			RE1="-e '/$2/s/\\($2\\)/$_TY\\1$_TN/'"
		fi
		[ "$SUPPRESS" ] && RE2=${RE2}p
		;;
	3)	if [ -n "$AND" ]; then
			# count matching words, use '@' as marker
			RE1="-e '/$1/s/\\(.*\\)/@\\1/'"
			RE2="-e '/$2/s/\\(.*\\)/@\\1/'"
			RE3="-e '/$3/s/\\(.*\\)/@\\1/'"
			# remove marker and eventually highlight if there are 3
			RE3=$RE3" -e 's/\\(@@@\\)\\(.*\\)/$_TB\\2$_TN/'"
			RE3=$RE3" -e 's/\\(@\\{1,3\\}\\)\\(.*\\)/\\2/'"
		else
			RE1="-e '/$1/s/\\($1\\)/$_TG\\1$_TN/'"
			RE2="-e '/$2/s/\\($2\\)/$_TY\\1$_TN/'"
			RE3="-e '/$3/s/\\($3\\)/$_TC\\1$_TN/'"
		fi
		[ "$SUPPRESS" ] && RE3=${RE3}p
		;;
	*)
		cle help ${BASH_SOURCE[0]}; return 1 ;;
	esac

	# prepare the filter to be run
	local RUN
	RUN="$READER sed $SUPPRESS $RE1 $RE2 $RE3"
	if [ $TSTAMP -gt 0 ]; then
		# loop in background prints timestamps, 
		bash -c "while true; do \
				date '+$_TR[%d-%m-%Y %T]$_TN'; \
				sleep $TSTAMP; \
			 done" &
		# trap ensures the loop will be terminated
		bash -c "trap 'kill $!' EXIT; $RUN"  
	else
		bash -c "$RUN"
	fi
	
	return
}
