#
# CLE : Command Live Environment
#
#* authors: Michael Arbet (marbet@redhat.com)
#*          Jakub Arbet (arbetjakub@gmail.com)
#* home:    https://github.com/micharbet/CLE
#* version: 2017-06-23 (RedH)
#* license: GNU GPL v2
#* Copyright (C) 2016-2017 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# Command line tweaks:
# -colorful prompt with hihglighted exit code
# -builtin aliases and functions
# -history tweaks (timestamps etc)
#
# Execute this file within your shell session
# and integrate into your profile:
# 
#	$ . clerc
#	$ cle deploy
#
# -use 'ssg' (ssh wrapper) to access remote system, CLE is seamlessly
#  started without installation
# -try suu/sudd (su/sudo wrappers) with same effect
# -alter settings using 'cle' command
# -store and manage your aliases with 'aa' function
# -use 'hh' function to ease history management
# -built-in self documenting feature 'cle help'
# -update from GIT source

# check running in interactive session otherwise skip all the tweaks
# required for scp compattibility
if [ -t 0 -a -z "$CLE_EXE" ];then

# a little bit complicated way to find absolute path
export CLE_RC=${BASH_SOURCE[0]}
CLE_DRC=$(cd `dirname $CLE_RC`;pwd;)
CLE_RC=$CLE_DRC/`basename $CLE_RC`

# who I'm
export CLE_USER=${CLE_USER:-$USER}

# session startup for su*
[ "$1" ] && { CLE_USER=$1; exec `command which bash` --rcfile $CLE_RC;}

# where in the deep space is CLE growing
CLE_SRC=https://raw.githubusercontent.com/micharbet/CLE/RedH
CLE_VER=`sed -n 's/^#\* version: //p' $CLE_RC`

# execute script and log its filename into CLE_EXE
# also ensure the script will be executed only once
_clexe () {
	[ -f "$1" ] || return 1
	[[ $CLE_EXE =~ :$1 ]] && return
	CLE_EXE=$CLE_EXE:$1
	. $1
}
CLE_EXE=$CLE_RC

case $CLE_RC in
*-remote-*) # remote session
	_clexe /etc/profile
	_clexe $HOME/.bashrc
	[ -w $HOME ] && _D=$HOME || _D=`dirname $CLE_RC`
	cd $_D;;
*/clerc*) # first run from commandline
	CLE_1=1
	_D=$HOME;;
*)	# locally deployed
	_D=$HOME
esac
CLE_D=${CLE_D:-$_D}

CLE_CF=${CLE_CF:-$CLE_D/.clecf-$CLE_USER}
CLE_RCU=$CLE_DRC/.cleusr-$CLE_USER

# tweaked hostname: remove domain, leave subdomains
CLE_THN=`hostname |sed 's;\.\w\+\.\w\+$;;'`
CLE_IP=`echo -n $SSH_CONNECTION | cut -d' ' -f3`

# color table
CT_N=`tput sgr0`
CT_L=`tput bold`
CT_U=`tput smul`;CT_UE=`tput rmul`
CT_D=`tput dim`
CT_RV=`tput rev`
_I=0; for _N in k r g y b m c w; do
        _C=`tput setaf $_I`
        declare CT_$_N=$CT_N$_C
        declare CT_$(echo $_N|tr a-z A-Z)=$CT_L$_C #bold
        ((_I+=1))
done
CT_E=`tput setab 1;tput setaf 7` # err highlight


#
# Internal helper functions
#

# boldprint
printb () { printf "$CT_w$*$CT_N\n";}

# simple question
ask () {
	read -p "$CT_L$* (y/N) $CT_N" -n 1 -s
	echo ${REPLY:=n}
	[ "$REPLY" = "y" ]
}

# banner
_clebanner () {
cat <<EOT

   ___|  |      ____|  Command Live Environment activated
  |      |      __|    ...bit of life to the command line
  |      |      |      Learn more:$CT_L cle help $CT_N
 \____| _____| _____| $CT_L less $CLE_RC$CT_N to discover the magic
 
EOT
}

# window title
_setwt () {
	CLE_WT=''
	[[ $TERM =~ linux ]] && return # no tits on console
	[[ $CLE_RC =~ remote ]] && CLE_WT="$CLE_USER -> "
	CLE_WT=$CLE_WT$USER@$CLE_THN:
}

# default config
_defcf () {
	CLE_PCOLOR=marley
	CLE_P0='%e \A'
	CLE_P1='\u'
	CLE_P2='%h'
	CLE_P3='\w %>'
}

# save configuration
_savecf () {
	echo "# $CLE_USER $CLE_VER"
	echo CLE_PCOLOR=$CLE_PCOLOR
	echo CLE_P0=\'$CLE_P0\'
	echo CLE_P1=\'$CLE_P1\'
	echo CLE_P2=\'$CLE_P2\'
	echo CLE_P3=\'$CLE_P3\'
} >$CLE_CF

# prompt enhancements
_pesc () (
	PP=">" # I hate $ in prompt
	[ $UID = 0 ] && PP="#"
	echo $*|sed \
	 -e "s/%i/$CLE_IP/"\
	 -e "s/%h/$CLE_THN/"\
	 -e "s/%u/$CLE_USER/"\
	 -e "s/%e/\\\$_E/"\
	 -e "s/%c\(.\)/\\\[\\\$CT_\1\\\]/g"\
	 -e "s/%v\([[:alnum:]]*\)/\1=\$\1/g"\
	 -e "s/%>/$PP/"
)

_cle_e () {
	[ "$1" != e ] && return
	printf "$CT_C\nH ${CT_c}CL${CT_C}E $CT_W  .-*$CT_R)$CT_W\`\`-. $CT_C\n"
	printf "a   a $CT_W /  $CT_R(($CT_b*$CT_W   '.$CT_C\np   s$CT_W |  $CT_b*$CT_R))$CT_W     #:"
	printf "$CT_C\np   t $CT_W \\  $CT_R(($CT_b*$CT_W   .'$CT_C\ny   er $CT_W '-.$CT_R)${CT_W}_.-'\n\n$CT_N"
}

# prompt composer
_setp () {
	local C0 C1 C2 I II P0 
	case "$CLE_PCOLOR" in 
	red)	C0=$CT_r;C2=$CT_R;;
	green)	C0=$CT_g;C2=$CT_G;;
	yellow)	C0=$CT_y;C2=$CT_Y;;
	blue)	C0=$CT_b;C2=$CT_B;;
	cyan)	C0=$CT_c;C2=$CT_C;;
	magenta) C0=$CT_m;C2=$CT_M;;
	white|grey|gray) C0=$CT_N;C1=$CT_w;C2=$CT_W;;
	bold)	C0=$CT_L;;
	tricolora) C0=$CT_R;C1=$CT_B;C2=$CT_W;;
	marley) # Bob Marley style :-) have a smoke and imagine...
		C0=$CT_R;C1=$CT_Y;C2=$CT_G;;
	???)	# any 3 colors
		for I in 0 1 2;do
			II=CT_${CLE_PCOLOR:$I:1}
			[ -z "${!II}" ] && echo "wrong color code '${CLE_PCOLOR:$I:1}' in $CLE_PCOLOR" && return 2
			declare C$I=${!II}
		done;;
	*)	# print help - whoa! self documented function
		echo "Unknown color '$CLE_PCOLOR' Select one of predefined:"
		declare -f _setp|sed -n 's/\(\<[a-z |]*\)).*/\1/p' 
		echo Or create your own 3-letter style using: rgbcmykw / RGBCMYKW
		echo e.g. cle color rgB
		return 2 
	esac
	# prepare prompt strings
	_PS1="\[$C0\]`_pesc $CLE_P1` \[$C1\]`_pesc $CLE_P2` \[$C2\]`_pesc $CLE_P3`"
	_PS0=`_pesc $CLE_P0`
	PS2="\[$C0\] >>>\[$CT_N\] "
	_savecf
}

# prompt function callback
_clepmt () {
	_E=$? # save return code
	local EE
	# highlight error code only in P0
	[ $_E = 0 ] && EE=[0] || EE="\[$CT_E\][$_E]\[$CT_N$CT_K\]"
	# final prompt composition
	PS1="\[$CT_K\]${_PS0/'$_E'/$EE} $_PS1 \[$CT_N\]"
	# window title
	[ "$CLE_WT" ] && printf "\033]0;$CLE_WT $PWD\007"
	# rich history
	_H=`history 1`
	unset IFS
	if [ "$_H" != "$_HO"  -a -n "$_HO" ];then
		echo "$_H" | { read N D T C; echo "$D $T $CLE_USER-$$ $_E $PWD $C" >>$CLE_HIST;}
	fi
	_HO=$_H
}
PROMPT_COMMAND=_clepmt

# filter for markdown files
mdfilter () {
	sed -e "s/^###\(.*\)/$CT_L\1$CT_N/"\
	 -e "s/^##\(\s*\)\(.*\)/\1$CT_U$CT_L\2$CT_N/"\
	 -e "s/^#\(\s*\)\(.*\)/\1$CT_L$CT_RV\2$CT_N/"\
	 -e "s/\*\*\(.*\)\*\*/$CT_L\1$CT_N/"\
	 -e "s/\<_\(.*\)_\>/$CT_U\1$CT_UE/g"\
	 -e "s/\`\([^\`]*\)\`/$CT_w\1$CT_N/g"
}

##
## Default aliases and functions:
## ------------------------------
_defalias () {
	## ls commands aliases: l ll la lt llr l. lld
	case $OSTYPE in
	linux*) alias ls='ls --color=auto';;
	darwin*)
		export CLICOLOR=1
		export LSCOLORS=ExGxBxDxCxEgEdxbxgxcxd;;
	*bsd*) alias ls='ls -G';;
	*) alias ls='ls -F' # at least some file type indication
	esac
	alias l='ls -l'
	alias ll='ls -l'
	alias lt='ls -ltr'
	alias la='ls -al'
	alias llr='ls -lR'
	alias lld='ls -ld'
	alias l.='ls -ld .?*'
	## cd command aliases:
	## .. ...     -- up one or two levels
	## cd-        -- cd to recent dir
	## -  (dash)  -- cd to recent dir
	alias ..='cd ..'
	alias ...='cd ../..'
	alias cd-='cd -'
	## xx & cx    -- bookmark & use path; stored in $XX
	alias xx='XX=`pwd`; echo path bookmark: XX=$XX'
	alias cx='cd $XX'
	alias grep='grep --color=auto'
	alias mv='mv -i'
	alias rm='rm -i'
}

# '-' must be function, alias was troublesome
- () { cd -;}

##
## Alias management:
## -----------------
CLE_ALIASES=$CLE_D/.aliases-$CLE_USER # personalized aliases
_clexe $CLE_ALIASES
_defalias

aa () {
	local ABK=$CLE_ALIASES.back TAL=$CLE_ALIASES.edit
	case "$1" in
	"")	## aa         -- show aliases
                alias|sed "s/^alias \(.\+\)='\(.\+\)'/$CT_w\1$CT_N\t\2/";;
	s)	## aa s       -- save current aliases
		alias;ask Save aliases? || return
		cp $CLE_ALIASES $ABK
		alias >$CLE_ALIASES
		printb Saved to file: $CLE_ALIASES
		printb Backup in: $ABK;;
	l)	## aa l       -- reload aliases
		unalias -a
		. $CLE_ALIASES;;
	ed)	## aa ed      -- edit and reload your aliases
		alias >$ABK
		cp $ABK $TAL
		vi $TAL
		mv $TAL $CLE_ALIASES
		aa l
		printb Backup in: $ABK;;
	*)	cle help aa
		return 1
	esac
}

##
## History workarounds:
## --------------------
HISTFILE=$CLE_D/.history-$CLE_USER
[ -f $HISTFILE ] || cp $HOME/.bash_history $HISTFILE
HISTCONTROL=ignoredups
HISTTIMEFORMAT="%Y-%m-%d %T "
HISTIGNORE="h:h *:hh*:aa*:l:l[alst]:pwd:cd:scrn"
CLE_HIST=$CLE_D/.history-ALL

## h               -- bash 'history' wrapper
h () (
	history $*|while read N D T C;do
		echo "$CT_B$N$CT_N $D $T $CT_w$C$CT_N"
	done
)

## hh [opt] [srch] -- rich history viewer
hh () (
	unset IFS
	while getopts "cst" O;do
		case $O in
		s) ONLY0=1;; ## hh -s           -- print successful commands only
		c) ONLYC=1;; ## hh -c           -- show just commands
		t) THIS=$CLE_USER-$$ ## hh -t           -- commands from current session
	esac;done
	shift $((OPTIND-1))
	grep "$THIS" $CLE_HIST | case $1 in
	"")	## hh [opt]        -- no search; print recent 100 items
		tail -100 ;;
	[0-9]|[0-9][0-9]|[0-9][0-9][0-9])
		## hh [opt] number -- find last N entries
		tail -$1;;
	*)	## hh [opt] string -- search in history
		grep $1
	esac | while read D T U E P C;do
	 [ $E != 0 -a "$ONLY0" ] && continue
	 case $E in
	 0)	EE=$CT_g;;
	 @)	EE=$CT_c;;
	 *)	EE=$CT_r
	 esac
	 [ "$ONLYC" ] && { [ $E = @ ] || echo $C;} ||\
	 	echo "$D $T $CT_b$U $EE$E $CT_N$P $CT_w$C$CT_N"
	done
)

##
## Session wrappers:
## -----------------

# environment packer
_clepak () (
	cd $CLE_DRC
	RCS=.clerc-remote-$CLE_USER
	[[ $CLE_RC =~ $RCS ]] || cp $CLE_RC $RCS
	touch $CLE_RCU; RCS="$RCS `basename $CLE_RCU`"
	tar chzf - $RCS | base64 | tr -d '\n\r '
)

## ssg [user@]host -- access remote system and take CLE along
ssg () (
	[ "$1" ] || { cle help ssg;return 1;}
	C64=`_clepak`
	`command which ssh` -t $* "
		[ -w $HOME ] || { mkdir /tmp/$CLE_USER; cd /tmp/$CLE_USER;}
		echo -n $C64|base64 --decode |tar xzf -;
		export CLE_USER=$CLE_USER;
		exec bash --rcfile .clerc-remote-$CLE_USER"
)

## sudd [user]     -- sudo wrapper; root is the default account
sudd () (
	sudo -i -u ${1:-root} $BASH $CLE_RC $CLE_USER
)

## suu [user]      -- su wrapper
suu () (
	if [[ $OSTYPE =~ bsd ]];then
		su -l ${1:-root} $CLE_RC $CLE_USER
	else
		su -l -s $BASH ${1:-root} $CLE_RC $CLE_USER # enforce bash
	fi
)

## kksu [user]     -- ksu wrapper
kksu () (
	ksu ${1:-root} -a -c "$BASH $CLE_RC $CLE_USER"
)

## scrn [-r]       -- gnu screen wrapper, lists active sessions to attach
##                    use -r to take control instead of join
scrn () (
	# obtain screens list
	SCRS=`screen -ls|sed -n "s/^[[:space:]]\+\([0-9]\+\..\+\)/\1/p"|tr " \t" "-"`
	if [ -n "$SCRS" ];then
		# join or take control
		[ "$1" = "-r" ] && SW="-DR" || SW="-x"
		[ $SW = -x ] && JR=join || JR="take control"
		printb ${CT_U}Current sessions:
		PS3="$CT_w choose # to $CT_W$JR$CT_w or <space> for new: $CT_N"
		select S in $SCRS;do
			[ $REPLY ] || break
			if [ $S ];then
				SS=`echo $S|cut -d- -f1`
				date "+$HISTTIMEFORMAT$CLE_USER-$$ @ $TTY [screen $SW $SS]" >>$CLE_HIST
				screen -S $SS -X echo "$CLE_USER is joining"
				exec screen $SW $SS
			fi
		done
	fi
	# start new session
	SCF=$CLE_D/.screenrc-$CLE_USER
	SN=$TTY.$CLE_USER
	date "+$HISTTIMEFORMAT$CLE_USER-$$ @ $TTY [screen -S $SN]" >>$CLE_HIST
	_scrc >$SCF
	screen -c $SCF -S $SN -t $USER bash --rcfile $CLE_RC
)

# screenrc generator
_scrc () {
cat <<-EOS
	altscreen on
	autodetach on
	# enables shift-PgUp/PgDn
	termcapinfo xterm* ti@:te@
	# change window with ctrl-left/right
	bindkey "^[[1;5D" prev
	bindkey "^[[1;5C" next
	defscrollback 3000
	hardstatus alwayslastline 
	hardstatus string '%{= Kk} %-w%{+u KC}%n %t%{-u Kk}%+w %-=%{KG}$CLE_THN%{Kg} %c'
	bind c screen -t $USER /bin/bash -rcfile \$CLE_RC
	source $HOME/.screenrc
EOS
}

# default settings
export EDITOR=vi
export PAGER="less -s"
PROMPT_DIRTRIM=2
shopt -s checkwinsize

# session record
TTY=`tty|sed -e 's./\|dev..g'`
date "+$HISTTIMEFORMAT$CLE_USER-$$ @ $TTY [${STY:-${SSH_CONNECTION:-$CLE_RC}}]" >>$CLE_HIST

# custom tweaks
_clexe $CLE_D/.clerc-local
_clexe $CLE_RCU

# load modules from .cle folder
for _I in $CLE_D/.cle/mod-*;do
	_clexe $_I
done

# prompt init
_clexe $CLE_CF || { _clebanner;_defcf;_savecf;}
_setp
_setwt

# enhance path with user's own bin
[[ -d $HOME/bin && ! $PATH =~ $HOME/bin ]] && PATH=$PATH:$HOME/bin

[ $CLE_1 ] && cat <<-EOT
 It seems you started CLE issuing '. $CLE_RC'
 Since this is the first run, consider setup in your profile.
 Following command will hook CLE in $HOME/.bashrc:
$CT_L	cle deploy

EOT

##
## CLE command & control:
## ----------------------
cle () {
	local C I S1 S2 MM BRC NC
	# find & run enhancement _cle_* function
	C=$1;shift
	if declare -f _cle_$C >/dev/null;then
		_cle_$C $*
		return $?
	fi
	case "$C" in
	color)	## cle color COLOR -- set prompt color
		I=$CLE_PCOLOR
		CLE_PCOLOR=$1
		_setp || CLE_PCOLOR=$I;;
	p?)	## cle p0-p3 [str] -- show/define prompt parts
		I=CLE_P${C:1:1}
		[ "$*" ] && eval "$I='$*'" || echo "$I='${!I}'"
		_setp;;
	time)	## cle time [off]  -- toggle server time in prompt
		[ "$1" = off ] && CLE_P0=%e || CLE_P0='%e \A'
		_setp;;
	title)	## cle title [off] -- toggle window title
		[ "$1" = off ] && CLE_WT='' || _setwt;;
	deploy)
		## cle deploy      -- hook CLE into user's profile
		I='# Command Live Environment'
		BRC=$HOME/.bashrc
		NC='$HOME/.clerc'
		if grep -A2 "$I" $BRC;then
			printb CLE is already hooked into .bashrc
		else
			printb CLE is to be integrated to your login script.
			ask Are you sure? || return
			eval cp $CLE_RC $NC
			printb Adding lines to your .bashrc:
			echo -e "\n$I\n[ -f $NC ] && . $NC\n" | tee -a $BRC
		fi;;
	update) ## cle update      -- install fresh version of CLE
		if [[ $CLE_RC =~ remote ]];then
			printb CLE in remote session, update is pointless.
			return 1
		fi
		NC=$CLE_D/clerc-new
		curl -k $CLE_SRC/clerc >$NC
		echo current: $CLE_VER
		echo "new:     `sed -n 's/^#\* version: //p' $NC`"
		S1=`md5sum $CLE_RC| cut -d' ' -f1`
		S2=`md5sum $NC| cut -d' ' -f1`
		[ $S1 = $S2 ] && { echo No difference; return 1;}
		ask Do you want to see diff? && diff $CLE_RC $NC
		ask Do you want to install new version? || return
		BRC=$CLE_D/clerc-back
		cp $CLE_RC $BRC
		mv $NC $CLE_RC
		cle reload
		printb New CLE activated, backup saved here: $BRC;;
	reload) ## cle reload      -- reload CLE
		unset CLE_EXE
		. $CLE_RC
		echo CLE $CLE_VER;;
	reset)	## cle reset       -- reset configuration
		rm -f $CLE_CF
		cle reload;;
	mod)	## cle mod         -- cle module management
		# this is just a fallback to initialize modularity
		# downloaded mod-mod overrides this code 
		ask Activate CLE modules? || return
		MM=$CLE_D/.cle/mod-mod
		mkdir $CLE_D/.cle
		curl -k $CLE_SRC/dotcle/mod-mod >$MM
		grep -q '# mod-mod:' $MM || { printb module download failed; rm -f $MM; return 1;}
		_clexe $MM
		cle mod avail;;
	env)	## cle env         -- print CLE_* variables
		set | grep ^CLE_.*=;;
	doc)	## cle doc         -- show documentation
		I=`curl -k $CLE_SRC/index.md`
		[[ $I =~ LICENSE$ ]] || { echo Unable to get documentation;return 1;}
		PS3="$CT_w doc #"
		select C in $I;do
			curl -k $CLE_SRC/$C |mdfilter|less -r; break
		done;;
	help)	## cle help [fnc]  -- show help
		# double hash denotes help content
		awk -F# "/[\t ]## *$1|^## *$1/ { print \$3 }" $CLE_RC;;
	"")	_clebanner
		sed -n 's/^#\*\(.*\)/\1/p' $CLE_RC;; # header
	*)	echo unimplemented: cle $C
		echo check cle help
		return 1
	esac
}

# remove disturbing stuff
unset SUDO_COMMAND _D _I _N _C
fi
# and that's all the magic :-)

