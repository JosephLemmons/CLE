#
# CLE : Command Live Environment
#
#* authors: Michael Arbet (marbet@redhat.com)
#*          Jakub Arbet (arbetjakub@gmail.com)
#* home:    https://github.com/micharbet/CLE
#* version: 2017-05-18 (HAlpha)
#* license: GNU GPL v2
#* Copyright (C) 2016-2017 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# Command line tweaks:
# - colorized prompt incl exit code highlight
# - builtin aliases and functions
# - history tweaks (timestamps etc)
# - personalized history for multi-admin environment
#
# Execute this file within your shell session once and integrate
# to your profile seamlessly with 'cle deploy' command
# 
#	$ . clerc
#	$ cle deploy user
#
# - use 'ssg' (ssh wrapper) to access remote system, CLE is seamlessly
#   started without installation
# - try suu/sudd (su/sudo wrappers) with same effect
# - change settings using 'cle' command
# - built-in self documentation feature ('cle help' 'cle readme' 'cle man')
# - store and manage your aliases with 'aa' function
# - use 'hh' function to ease history management
# - self update from GIT source

# check running in interactive session and if not, skip all the tweaks
# required for scp compattibility
if [ -n "TERM" -a "$TERM" != "dumb" -a -z "$CLE_EXE" ]; then

# a little bit complicated way to find absolute path
CLE_RC=${BASH_SOURCE[0]}
CLE_DRC=$(cd `dirname $CLE_RC`; pwd;)
CLE_RC=$CLE_DRC/`basename $CLE_RC`

# who I'm
export CLE_USER=${CLE_USER:-$USER}

# new session startup for su*
if [ -n "$1" ]; then
	CLE_USER=$1
	exec `command which bash` --rcfile $CLE_RC
fi

# where in the deep space is CLE growing
CLE_SRC=https://raw.githubusercontent.com/micharbet/CLE/master
CLE_VERSION=`sed -n 's/^#\* version: //p' $CLE_RC`

# execute script and log its filename into CLE_EXE to keep track
# also ensure the script will be executed only once
_clexe () {
	if [ -f "$1" ]; then
		[[ $CLE_EXE =~ :$1 ]] && return
		CLE_EXE=$CLE_EXE:$1
		[ -n "$CLE_VERB" ] &&  echo ${CT_w}clexe: $CT_N $1
		. $1
	fi
}
CLE_EXE=$CLE_RC

case $CLE_RC in
*.clerc-remote-*) # remote session
	_clexe /etc/profile
	_clexe $HOME/.bashrc
	[ -w $HOME ] && CLE_DR=$HOME || CLE_DR=`dirname $CLE_RC` ;;
*/clerc*) # first run from commandline
	[ -z "$CLE_DK" ] && CLE_FIRST=1
	CLE_DR=$HOME ;;
*)	# locally deployed
	CLE_DR=$HOME
esac
CLE_DIR=${CLE_DIR:-$CLE_DR}

CLE_CF=${CLE_CF:-$CLE_DIR/.clecf-$CLE_USER}
CLE_RCU=$CLE_DRC/.cleusr-$CLE_USER

# tweaked hostname, can be altered in .clerc-local or .cleusr-$CLE_USER
CLE_THN=`hostname |sed 's;\.\w\+\.\w\+$;;'` # remove domain, leave subdomains
CLE_IP=`echo -n $SSH_CONNECTION | cut -d' ' -f3`

# color table initializattion
CT_N=`tput sgr0` # reset
CT_L=`tput bold`
CT_U=`tput smul`; CT_UE=`tput rmul`
CT_D=`tput dim`
CT_RV=`tput rev`
CT=`tput setaf 0`; CT_k=$CT_N$CT; CT_K=$CT_L$CT
CT=`tput setaf 1`; CT_r=$CT_N$CT; CT_R=$CT_L$CT
CT=`tput setaf 2`; CT_g=$CT_N$CT; CT_G=$CT_L$CT
CT=`tput setaf 3`; CT_y=$CT_N$CT; CT_Y=$CT_L$CT
CT=`tput setaf 4`; CT_b=$CT_N$CT; CT_B=$CT_L$CT
CT=`tput setaf 5`; CT_m=$CT_N$CT; CT_M=$CT_L$CT
CT=`tput setaf 6`; CT_c=$CT_N$CT; CT_C=$CT_L$CT
CT=`tput setaf 7`; CT_w=$CT_N$CT; CT_W=$CT_L$CT
CT_E=`tput setab 1; tput setaf 7` # err highlight

#
# Internal helper functions
#

# boldprint
printb () { printf "$CT_w$*$CT_N\n"; }

# simple question
ask () {
	read -p "$CT_L$* (y/N) $CT_N" -n 1 -s
	echo ${REPLY:=n}
	[ "$REPLY" == "y" ]
}

# banner
_clebanner () {
cat <<EOT

   ___|  |      ____|  Command Live Environment activated
  |      |      __|    ...bit of life to the command line
  |      |      |      Learn more:$CT_L cle help $CT_N
 \____| _____| _____| $CT_L less $CLE_RC$CT_N to discover the magic
 
EOT
}

# default window title
_defwt () {
	CLE_WT=''
	[[ $TERM =~ 'linux' ]] && return # no tits on console
	[[ $CLE_RC =~ remote ]] && CLE_WT="$CLE_USER -> "
	CLE_WT="$CLE_WT$USER@$CLE_THN:"
}

# default prompt
_defcf () {
	CLE_PCOLOR='marley'
	CLE_P0='%e \A'
	CLE_P1='\u'
	CLE_P2='%h'
	CLE_P3='\w %>'
}

# save configuration
_savecf () {
	echo "# $CLE_USER $CLE_VERSION"
	echo CLE_PCOLOR=\'$CLE_PCOLOR\'
	echo CLE_P0=\'$CLE_P0\'
	echo CLE_P1=\'$CLE_P1\'
	echo CLE_P2=\'$CLE_P2\'
	echo CLE_P3=\'$CLE_P3\'
} >$CLE_CF

# prompt enhancements
_pesc () {
	local PP=">" # I hate $ in prompt
	[ $UID == 0 ] && PP="#"
	echo $*|sed \
	 -e "s/%i/$CLE_IP/" \
	 -e "s/%h/$CLE_THN/" \
	 -e "s/%u/$CLE_USER/" \
	 -e "s/%e/\\\$_E/" \
	 -e "s/%c\(.\)/\\\[\\\$CT_\1\\\]/g" \
	 -e "s/%v\([[:alnum:]]*\)/\1=\$\1/g" \
	 -e "s/%>/$PP/"
}

_cle_e () {
	[ "$1" != e ] && return
	printf "$CT_C\nH ${CT_c}CL${CT_C}E $CT_W  .-*$CT_R)$CT_W\`\`-. $CT_C\n"
	printf "a   a $CT_W /  $CT_R(($CT_b*$CT_W   '.$CT_C\np   s$CT_W |  $CT_b*$CT_R))$CT_W     #:"
	printf "$CT_C\np   t $CT_W \\  $CT_R(($CT_b*$CT_W   .'$CT_C\ny   er $CT_W '-.$CT_R)${CT_W}_.-'\n\n$CT_N"
}

# prompt composer
_setp () {
	local C0 C1 C2 I II P0 
	case "$CLE_PCOLOR" in 
	red)	C0=$CT_r; C2=$CT_R;;
	green)	C0=$CT_g; C2=$CT_G;;
	yellow)	C0=$CT_y; C2=$CT_Y;;
	blue)	C0=$CT_b; C2=$CT_B;;
	cyan)	C0=$CT_c; C2=$CT_C;;
	magenta) C0=$CT_m; C2=$CT_M;;
	white|grey|gray) C0=$CT_N; C1=$CT_w; C2=$CT_W;;
	bold)	C0=$CT_L;;
	tricolora) C0=$CT_R; C1=$CT_B; C2=$CT_W;;
	marley) # ... Bob Marley style :-) have a smoke and imagine...
		C0=$CT_R; C1=$CT_Y; C2=$CT_G;;
	???)	# ... any 3 colors
		for I in 0 1 2; do
			II=CT_${CLE_PCOLOR:$I:1}
			[ -z "${!II}" ] && echo "wrong color code '${CLE_PCOLOR:$I:1}' in $CLE_PCOLOR" && return 2
			declare C$I=${!II}
		done;;
	*)	# print help - whoa! self documented function :)
		echo "Unknown color '$CLE_PCOLOR' Select one of predefined:"
		declare -f _setp|sed -n -e 's/\ *\(\<[a-zA-Z |]*\)).*/ \1 /p' 
		echo "Or create your own 3-letter style using: rgbcmykw / RGBCMYKW"
		echo " e.g. 'cle color rgB'"
		return 2 
	esac
	# prepare prompt strings
	_PS1="\[$C0\]`_pesc $CLE_P1` \[$C1\]`_pesc $CLE_P2` \[$C2\]`_pesc $CLE_P3`"
	_PS0=`_pesc $CLE_P0`
	PS2="\[$C0\] >>>\[$CT_N\] "
	_savecf
}

# prompt function - called upon each new prompt line
_clepmt () {
	_E=$? # save last return code
	local EE
	# highilighted error code only in P0
	if [ $_E -eq 0 ]; then
		EE="[0]"
	else
		EE="\[$CT_E\][$_E]\[$CT_N$CT_K\]"
	fi
	# final prompt composition
	PS1="\[$CT_K\]${_PS0/'$_E'/$EE} $_PS1 \[$CT_N\]"
	# change window title
	[ -n "$CLE_WT" ] && printf "\033]0;$CLE_WT $PWD\007"
	# shared history
	[ -n "$CLE_HSH" ] && { history -a; history -c; history -r; }
}
PROMPT_COMMAND=_clepmt

# filter for markdown files
mdfilter () {
	sed -e "s/^###\(.*\)/$CT_L\1$CT_N/" \
	 -e "s/^##\(\s*\)\(.*\)/\1$CT_U$CT_L\2$CT_N/" \
	 -e "s/^#\(\s*\)\(.*\)/\1$CT_L$CT_RV\2$CT_N/" \
	 -e "s/\*\*\(.*\)\*\*/$CT_L\1$CT_N/" \
	 -e "s/\<_\(.*\)_\>/$CT_U\1$CT_UE/g" \
	 -e "s/\`\([^\`]*\)\`/$CT_w\1$CT_N/g"
}

##
## Default aliases and functions:
## ------------------------------
_defalias () {
	## ls commands aliases: l ll la lt llr l. lld
	if [[ "$OSTYPE" =~ "linux" ]]; then
                alias ls='ls --color=auto'
        elif [[ "$OSTYPE" =~ "darwin" ]]; then
                export CLICOLOR=1
                export LSCOLORS="ExGxBxDxCxEgEdxbxgxcxd"
        elif [[ "$OSTYPE" =~ "freebsd" ]]; then
                alias ls='ls -G'
	else
		alias ls='ls -F' # at least some file type indication
        fi
	alias l='ls -l'
	alias ll='ls -l'
	alias lt='ls -ltr'
	alias la='ls -al'
	alias llr='ls -lR'
	alias lld='ls -ld'
	alias l.='ls -ld .?*'
	## cd command aliases:
	## .. ...     -- up one or two levels
	## cd-        -- cd to recent dir
	## -  (dash)  -- cd to recent dir
	alias ..='cd ..'
	alias ...='cd ../..'
	alias cd-='cd -'
	## xx & cx    -- path bookmark; set and 'cd' later, stored in $XX
	alias xx='XX=`pwd`; echo path boorkmark set here: XX=$XX'
	alias cx='cd $XX'
	alias grep='grep --color=auto'
	alias mv='mv -i'
	alias rm='rm -i'
}

# '-' must be function, alias was troublesome
- () { cd -; }

##
## Alias management
## ----------------
CLE_ALIASES=$CLE_DIR/.aliases-$CLE_USER # personalized aliases
_clexe $CLE_ALIASES
_defalias

aa () {
	local ABAK=$CLE_ALIASES.back
	case "$1" in
	"")	## aa         -- show aliases
		alias ;;
	s)	## aa s       -- save your set of aliases
		alias
		ask "Save aliases?" || return
		cp $CLE_ALIASES $ABAK
		alias >$CLE_ALIASES
		echo Saved to file: $CLE_ALIASES
		echo Backup in: $ABAK ;;
	l)	## aa l       -- (re)load your set of aliases
		unalias -a
		. $CLE_ALIASES ;;
	ed)	## aa ed      -- edit and reload your aliases
		local TALIAS=$CLE_ALIASES.edit
		alias >$ABAK
		cp $ABAK $TALIAS
		vi $TALIAS
		mv $TALIAS $CLE_ALIASES
		aa l
		echo Backup in: $ABAK ;;
	*)	
		echo " unimplemented: aa $1 $2"
		cle help aa
	esac
}

##
## History management
## ------------------
hh () {
	case $1 in
	"")	## hh         -- just print history
		history ;;
	[0-9]|[0-9][0-9]|[0-9][0-9][0-9])
		## hh number  -- print last N entries
		history $1 ;;
	shon)	## hh shon    -- turn on sharing history between terminals
		CLE_HSH=1 ;;
	*)	## hh string  -- search in history
		history | grep -i $1
	esac
}

##
## Session wrappers:
## -----------------

# environment packer
_clepak () (
	cd $CLE_DRC
	CLES=.clerc-remote-$CLE_USER
	[[ $CLE_RC =~ $CLES ]] || cp $CLE_RC $CLES
	[ -f $CLE_RCU ] && CLES="$CLES `basename $CLE_RCU`"
	tar chzf - $CLES | base64 | tr -d '\n\r '
)

## ssg [user@]hostname  -- access remote system and take CLE along
ssg () (
	if [ -n "$1" ]; then
		CLE_64=`_clepak`
		`command which ssh` -t $* "
			[ -w $HOME ] || { mkdir /tmp/$CLE_USER 2>/dev/null; cd /tmp/$CLE_USER;}
			echo -n $CLE_64|base64 --decode |tar xzf -;
			export CLE_USER=$CLE_USER;
			exec bash --rcfile .clerc-remote-$CLE_USER"
	else 
		cle help ssg
	fi
)

## sudd [username]      -- sudo wrapper; root is the default account
sudd () (
	sudo -i -u ${1:-root} $BASH $CLE_RC $CLE_USER
)

## suu [username]       -- su wrapper
suu () (
	if [[ $OSTYPE =~ bsd ]]; then
		su -l ${1:-root} $CLE_RC $CLE_USER
	else
		# enforcing bash
		su -l -s $BASH ${1:-root} $CLE_RC $CLE_USER
	fi
)

## kksu [username]      -- ksu wrapper
kksu () (
	ksu ${1:-root} -a -c "$BASH $CLE_RC $CLE_USER"
)

# default shell settings
export EDITOR=vi
export PAGER="less -s"
PROMPT_DIRTRIM=2
shopt -s checkwinsize
HISTFILE=$CLE_DIR/.history-$CLE_USER
# history file must not be empty!
[ -f $HISTFILE ] || { cp $HOME/.bash_history $HISTFILE 2>/dev/null || echo ls >$HISTFILE; }
HISTCONTROL=ignoredups
HISTTIMEFORMAT="%d%b %H:%M:%S  "

# load config and custom tweaks
_clexe $CLE_CF
[ -n "$CLE_VERB" ] && { echo CLE config:; cat $CLE_CF; echo; }
_clexe $CLE_DIR/.clerc-local
_clexe $CLE_RCU

# indicate first run, show banner, create default conf
[ -f $CLE_CF ] || { _clebanner; _defcf; _savecf; }
[[ -n "$CLE_FIRST" ]] && cat <<-EOT
$CT_w It seems you started CLE from command line issuing '. $CLE_RC'
 Since this is your first run, consider setting up in your profile.
 Following command will hook CLE in your $HOME/.bashrc
$CT_L    cle deploy$CT_N
EOT

# load modules from .cle folder
for MD in $CLE_DIR/.cle/mod-*; do
	_clexe $MD
done
unset MD

_defwt
_setp

# enhance path with user's own bin directory
[[ -d $HOME/bin && ! $PATH =~ $HOME/bin ]] && PATH=$PATH:$HOME/bin

##
## CLE command & control:
## ----------------------
cle () {
	local CMD=$1; shift
	if declare -f _cle_$CMD >/dev/null; then
		# run any _cle_* function
		# those might be defined e.g. in modules .cle/mod-*
		_cle_$CMD $*
		return $?
	fi
	case "${CMD}" in
	color)	## cle color COLOR    -- set prompt color
		local CPC=$CLE_PCOLOR
		CLE_PCOLOR=$1
		_setp || CLE_PCOLOR=$CPC ;;
	p0)	## cle p0-p3 [string] -- define prompt part 0-3
		CLE_P0="${*:-%e \A}"
		_setp ;;
	p1)
		CLE_P1="${*:-\\u}"
		_setp ;;
	p2)
		CLE_P2="${*:-%h}"
		_setp ;;
	p3)
		CLE_P3="${*:-\\w %>}"
		_setp ;;
	time)	## cle time [off]     -- toggle server time in prompt
		[ "$1" == "off" ] && CLE_P0='%e'
		[ -z "$1" ] && CLE_P0='%e \A'
		_setp ;;
	title)	## cle title [off]    -- toggle window title
		[ "$1" == "off" ] && CLE_WT=''
		[ -z "$1" ] && _defwt 
		;;
	deploy)
		## cle deploy         -- hook CLE into user's profile
		local CLID='# Command Live Environment'
		local BRC=$HOME/.bashrc
		cp $CLE_RC $CLE_DIR/.clerc
		grep -q "$CLID" $BRC 
		if [ $? != 0 ]; then
			printb "CLE is to be integrated to your login script."
			ask " Are you sure?" || return
			echo -e >>$BRC \\n$CLID
			echo -e >>$BRC "[ -f $CLE_DIR/.clerc ] && . $CLE_DIR/.clerc\n"
			printb '\n ...lines added to your .bashrc :'
			tail -2 $BRC
		else
			printb "CLE is already hooked into .bashrc :"
			command grep -A2 "$CLID" $BRC
		fi ;;
	update) ## cle update         -- install fresh version of CLE
		if [[ $CLE_RC =~ remote ]]; then
			printb CLE in remote session, update is pointless.
			return 1
		fi
		local NCLE=$CLE_DIR/clerc-new
		curl -k $CLE_SRC/clerc >$NCLE
		printb "New CLE here: $NCLE"
		echo "current: $CLE_VERSION"
		echo "new:     `sed -n 's/^#\* version: //p' $NCLE`"
		local SUM1=`md5sum $CLE_RC| cut -d' ' -f1`
		local SUM2=`md5sum $NCLE| cut -d' ' -f1`
		[ $SUM1 == $SUM2 ] && { echo No difference; return 1; }
		ask "Do you want to see diff?" && diff $CLE_RC $NCLE
		ask "Do you want to install new version?" || return
		cp $CLE_RC $CLE_DIR/clerc-back
		mv $NCLE $CLE_RC
		cle reload
		printb "New CLE has been installed, previous version saved here: $CLE_DIR/clerc-back" ;;
	reload) ## cle reload         -- reload CLE
		unset CLE_EXE
		printb Reloading CLE from $CLE_RC
		. $CLE_RC
		echo CLE $CLE_VERSION ;;
	mod)	## cle mod            -- cle module management
		# this is just a fallback for initialize modularity
		# downloaded mod-mod overrides this code 
		ask "Activate CLE modules?" || return
		local MM=$CLE_DIR/.cle/mod-mod
		mkdir $CLE_DIR/.cle
		curl -k $CLE_SRC/dotcle/mod-mod >$MM
		grep -q '# mod-mod:' $MM || { printb module download failed; rm -f $MM; return 1; }
		_clexe $MM
		cle mod avail
		;;
	env)	## cle env            -- print CLE_* variables
		set | grep ^CLE_.*= ;;
	cf)	## cle cf             -- show configuration
		printb Config: $CLE_CF
		cat $CLE_CF ;;
	reset)	## cle reset          -- reset configuration
		rm -f $CLE_CF
		cle reload ;;
	readme) ## cle readme         -- download and show README file
		curl -k $CLE_SRC/README.md | mdfilter |less -r ;;
	man)	## cle man            -- download and show HOWTO file
		curl -k $CLE_SRC/HOWTO.md | mdfilter |less -r ;;
	help)	## cle help [fnc|mod] -- show help for fuction or module
		# double hash denotes help content
		if [ -z "$1" ]; then
			# overview
			awk -F# "/[\t ]##|^##/ { print \$3 }" $CLE_RC
		elif declare -f $1 >/dev/null; then
			# extract one cle function
			awk -F# "/[\t ]## *$1|^## *$1/ { print \$3 }" $CLE_RC
		elif [ -f $1 ]; then
			# extract from given files
			awk -F# "/[\t ]##|^##/ { print \$3 }" $*
		else # search in modules
			local HF=`echo $CLE_EXE | tr : '\n' |grep mod-.\*$1`
			[ -n "$HF" ] && cle help $HF || echo ...no help for you
		fi ;;
	"")	_clebanner
		sed -n 's/^#\*\(.*\)/\1/p' $CLE_RC # header
		;;
	*)	echo "'cle $CMD' not implemeted"
		echo "check cle help"
		return 1
	esac
}

# remove disturbing stuff
unset SUDO_COMMAND CLE_VERB CLE_DR

fi
# and that's all the magic :-)

