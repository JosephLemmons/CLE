#
## CLE :: Command Live Environment
## author: Michael Arbet (marbet@redhat.com)
## version: 3  17 August 2016
## license: GNU GPL 3
## https://gitlab.cee.redhat.com/marbet/cle
##
# bash tweaks
# - colorized prompt with exit code highlight
# - builtin aliases and functions
# - history tweaks (timestamps etc), shell options
# - command 'cle' to control the environment
# - builtin self documentation feature (cle help & cle readme)
#
# Execute this file within your shell session once and integrate
# to your profile seamlessly with 'cle deploy local' command
# 
#        $ . clerc
#        $ cle deploy user
#
# - use implemented 'ssg' (ssh workaround) and seamlessly pass
#   this environment to remote machine without installation
# - try 'suu' (sudo workaround) 
# - change settings with implememted 'cle' command

# check if this is interactive session and if not, skip all the tweaks
# this is required for scp compattibility if initiated from .bashrc
if [ -n "TERM" -a "$TERM"!="dumb" ]; then
CLE_LCLUSER=`whoami`

CLE_RC=${BASH_SOURCE[0]}
case $CLE_RC in
/*)	;;
*)	CLE_RC=$PWD/$CLE_RC ;;
esac
CLE_EXE=$CLE_RC
CLE_VERSION=`grep -m1 "# version:" $CLE_RC | cut -d' ' -f3-`

# determine effective user and custom script
# CLE_EFUSER is passed to all consecutive sessions initiated with ssg/suu
CLE_CUSTOMRC=$HOME/.cle-${CLE_EFUSER:=$CLE_LCLUSER}

# where in the deep space is CLE growing... you may change with your own url
CLE_ORIGIN='https://gitlab.cee.redhat.com/marbet/cle/raw/master'
 
# tweaked hostname - removing some substrings (redhat and gss)
CLE_HN=`hostname | sed -e 's/.redhat.com//' -e 's/.gsslab//'`
# CLE_HN=`hostname`

# default prompt settings
CLE_TIME='\A'
CLE_COLOR='marley'
CLE_PROMPT=$HOME/.cleprompt-$CLE_EFUSER

# color table initializattion
declare -A CT
CT_N=`tput sgr0` # reset
CT_L=`tput bold`
CT_E=`tput setab 1; tput setaf 7` # err highlight
I=0; for CCODE in k r g y b m c w; do
	CT[$CCODE]=$CT_N`tput setaf $I`
	CT[${CCODE^}]=$CT_L`tput setaf $I`
	((I++))
done

# default shell settings can ge overridden later
export EDITOR=vi
export PAGER="less -s"
HISTCONTROL=ignorespace:ignoredups:erasedups
HISTTIMEFORMAT="%d%b %H:%M:%S  "
PROMPT_DIRTRIM=2
shopt -s checkwinsize

#
# Internal helper functions
#

# print banner
_clebanner () {
cat <<EOT

   ___|  |      ____|    Command Live Environment activated
  |      |      __|      ...bit of life to the command line
  |      |      |           'cle help'      to learn more 
 \____| _____| _____|    or 'less $CLE_RC'  to discover the magic
 
EOT
}

# execute associated script and log its filename into CLE_EXE to keep track
# also ensure the script will be executed only once
_clexe () {
	echo $CLE_EXE|grep -q $1 && return
	[ -f $1 ] && CLE_EXE=$CLE_EXE:$1 && . $1
}

# save prompt related variables
_clepromptsave () {
	echo CLE_COLOR=\'$CLE_COLOR\' >$CLE_PROMPT
	echo CLE_TIME=\'$CLE_TIME\' >>$CLE_PROMPT
}

# colorizer
_clecolor () {
	local C1 C2 C3 I
	case "$1" in 
	red)	 C1=${CT[r]}; C3=${CT[R]} ;;
	green)	 C1=${CT[g]}; C3=${CT[G]} ;;
	yellow)	 C1=${CT[y]}; C3=${CT[Y]} ;;
	blue)	 C1=${CT[b]}; C3=${CT[B]} ;;
	magenta) C1=${CT[m]}; C3=${CT[M]} ;;
	cyan)	 C1=${CT[c]}; C3=${CT[C]} ;;
	bold)    C1=$CT_L ;;
	white|grey|gray) C1=${CT[K]}; C2=${CT[w]}; C3=${CT[W]};;
	tricolora) C1=${CT[R]}; C2=${CT[B]}; C3=${CT[W]};;
	marley) # ... Bob Marley style :-) have a smoke and imagine...
		C1=${CT[R]}; C2=${CT[Y]}; C3=${CT[G]};;
	???)	# ... any 3 colors
		C1=${CT[${1:0:1}]}; C2=${CT[${1:1:1}]}; C3=${CT[${1:2:1}]} ;;
	*)	# print help
		echo " unknown color $1, select one of predefined:"
		declare -f _clecolor|sed -n 's/\(\<[a-zA-Z]*\)).*/\1/p'
		echo " or create your own 3-letter style using this:"
		echo "  rgbcmykw and RGBCMYKW (e.g 'cle color GyY')"
		return 2
	esac
	# compose prompts
	CLE_PS="\[$C1\]\u \[$C2\]$CLE_HN \[$C3\]\w \\$"
	PS2="\[$C1\] \\$>>>\[$CT_N\] "
	CLE_COLOR=$1
	_clepromptsave
}

# prompt function - called upon each new prompt line
_cleprompt () {
	local EEP EE=$?  # store exit status code (it would disappear!)
	if [ $EE -eq 0 ]; then
		EEP="\[${CT[K]}\][$EE]"
	else
		EEP="\[$CT_E\][$EE]\[$CT_N${CT[K]}\]"
	fi
	# Final prompt composition
	PS1="$EEP${CLE_TIME:+ $CLE_TIME} \[$CT_N\]$CLE_PS\[$CT_N\] "
	# change window title TERMPORARY DISABLED
	# echo -en "\e]0;$CLE_EFUSER -> $LOGNAME@$CLE_HN: $PWD\007"
}
PROMPT_COMMAND=_cleprompt

case $CLE_RC in
*.clerc-tmp-*)	# old good .bashrc :-) but only from temporary environment
	_clexe $HOME/.bashrc
	;;
*/clerc)	# this looks like initial run from commandline
	_clebanner
	echo "If this is your first run, consider setting up in your profile."
	echo "Issue following command to copy source script into $HOME/.clerc"
	echo -e "and activate the environment in $HOME/.bashrc\n"
	echo -e "     $CT_L cle deploy user $CT_N\n"
	;;
esac

# local setup like e.g CLE_COLOR, CLE_PS, CLE_HN, CLE_TIME, anything...
_clexe $HOME/.clerc_local
_clexe $CLE_PROMPT

# execute plugins from .cle folder
for PLUG in $HOME/.cle/*; do
	_clexe $PLUG
done

_clecolor $CLE_COLOR

# basic aliases - those might be overridden by .aliases file
#
## CLE internal aliases and functions:
## -----------------------------------
## ls commands aliases: l ll la lt llr l.
alias ls='ls --color=auto'
alias ll='ls -l'
alias l='ls -l'
alias lt='ls -ltr'
alias la='ls -al'
alias llr='ls -lR'
alias l.='ls -ld .?*'
## cd command aliases:  .. ... (up one or two levels); c- (cd to the recent dir)
alias ..='cd ..'
alias ...='cd ../..'
alias c-='cd -'
## xx & cx       -- directory bookmark; set it and 'cd' there
# what about to define x1/c1, x2/c2, etc...
alias xx='XPOINT=`pwd`; echo Directory boorkmark set here: $XPOINT'
alias cx='cd $XPOINT'
alias grep='grep --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias hh=history

# store basic alias set if there is none
[ -f $CLE_ALIASES ] || alias >$CLE_ALIASES

# personalized aliases
CLE_ALIASES=$HOME/.aliases-$CLE_EFUSER
HISTFILE=$HOME/.bash_history-$CLE_EFUSER  # private history files
_clexe $CLE_ALIASES

#
# functions
#

## path          -- show $PATH in readable way
path () {
	echo $PATH|tr : \\n
}

## psg           -- ps filtered through grep
psg () {
 ps -ef |grep -i $1|grep -v grep
}

##
## alias management
## ----------------
aa () {
	case "$1" in
	"") ## aa         -- show aliases
		alias ;;
	save) ## aa save    -- save your set of aliases
		alias
		echo; read -p "ENTER for save, Ctrl-C"
		alias >$CLE_ALIASES
		echo Saved to file .$CLE_ALIASES
		;;
	load) ## aa load    -- (re)load your set of aliases
		unalias -a
		. $CLE_ALIASES
		;;
	edit) ## aa edit    -- edit and reload your aliases
		local TALIAS=$HOME/.aiases-tmp-$CLE_EFUSER
		alias >$TALIAS
		vi $TALIAS
		echo; read -p "ENTER to reload, Ctrl-C to break"
		mv $TALIAS $CLE_ALIASES
		aa load
		;;
	*)	
                echo " what??  'aa $1 $2'"
                echo " check this: cle help"
                ;;
	esac
}

##
## SSH & SUDO wrappers:
## --------------------
## ssg [user@]hostname  -- login to remote system running this environment
# You can replace 'ssg' with 'ssh' although this is not recommended
ssg () {
	cd
	if [ -n "$1" ]; then
		cp $CLE_RC .clerc-tmp-$LOGNAME 2>/dev/null
		CLE_64=`tar czf - .clerc-tmp-$LOGNAME $CLE_MYFILES|base64|tr -d '\n\r '`
		`/usr/bin/which ssh` -t $1 "
			echo $CLE_64|base64 -d |tar xzf -
			export CLE_EFUSER=$CLE_EFUSER;
			exec bash --rcfile .clerc-tmp-$LOGNAME"
	else
		cle help ssg
	fi
	unset CLE_64
	cd -
}

## suu [username]       -- sudo wrapper; root is the default account
suu () {
	cd
	cp $CLE_RC .clerc-tmp-$LOGNAME 2>/dev/null
	CLE_64=`tar czf - .clerc-tmp-$LOGNAME $CLE_MYFILES|base64|tr -d '\n\r '`
	sudo -i -u ${1:-root} /bin/bash  -c \
		"echo $CLE_64|base64 -d | tar xzf -;
		 export CLE_EFUSER=$CLE_EFUSER;
		 exec bash --rcfile .clerc-tmp-$LOGNAME"
	unset CLE_64
	cd -
}

##
## CLE command & control:
## ----------------------
cle () {
	case "$1_$2" in
	color_*) ## cle color blue|green|red|marley|..etc  -- set prompt color
		_clecolor $2 ;;
	time_on) ## cle time on|off     -- turn server time in prompt on/off
		CLE_TIME='\A'
		_clepromptsave ;;
	time_off)
		CLE_TIME=''
		_clepromptsave ;;
	time_*) ## cle time STRING     -- set custom strings
		shift
		CLE_TIME="$*"
		_clepromptsave ;;
	deploy_user)
		## cle deploy user     -- hook CLE into user's profile
		local CLID='# Command Live Environment'
		local BRC=$HOME/.bashrc
		cp $CLE_RC $HOME/.clerc
		grep -q "$CLID" $BRC 
		if [ $? != 0 ]; then
			echo " CLE is to be integrated to your login script."
			read -p " Are you sure? (y/N) "
			[ "$REPLY" != 'y' ] && return
			echo -e >>$BRC \\n$CLID
			echo -e >>$BRC '[ -f $HOME/.clerc ] && . $HOME/.clerc\n'
			echo -e '\n ... added following to the end of .bashrc :'
			tail -4 $BRC
		else
			echo " CLE is already hooked into .bashrc :"
			grep -A2 "$CLID" $BRC
		fi ;;
	deploy_system)
		## cle deploy system   -- hook CLE into /etc/profile.d
		echo " CLE is to be integrated into your system!"
		echo " Content of $CLE_RC will be copied to /etc/profile.d/cle.sh"
		echo " The environment will be activated for all users."
		echo " Only root can do that..."
		read -p " Are you sure? (y/N) "
		[ "$REPLY" != 'y' ] && return
		cp $CLE_RC /etc/profile.d/cle.sh
		echo " Done!"
		;;
	reload_) ## cle reload          -- reload CLE
		unset CLE_EXE
		. $CLE_RC ;;
	update_) ## cle update          -- download newest version of CLE
		curl -k $CLE_ORIGIN/clerc >$HOME/clerc-new
		echo "New CLE has been stored here: $HOME/clerc-new"
		read -p "Press Enter to show diff or Ctrl-C to break"
		diff $CLE_RC $HOME/clerc-new
		# no setup for now, need to think more about it
		;;
	readme_) ## cle readme          -- download and show README file
		curl -k $CLE_ORIGIN/README.md |less ;;
	help_*) ## cle help [cmd]      -- self documenting feature
		# double-hash denotes help content :-)
		[ -z "$2" ] && _clebanner
		awk -F# "/## *$2/"' { print $3 }' $CLE_RC
		;;
	*)
		_cle_$1 $2
		if [ $? -eq 127 ]; then 
			echo " 'cle $1' not implemeted"
			echo " check this: cle help"
		fi ;;
	esac
}

# enhance path with user's own bin directory
[ -d $HOME/bin ] && echo $PATH | grep -vq $HOME/bin && PATH=$PATH:$HOME/bin

# remove disturbing stuff
unset SUDO_COMMAND

# run personal tweaks
_clexe $CLE_CUSTOMRC

# indicate first run, show banner
[ -f $CLE_PROMPT ] || _clebanner && _clepromptsave

fi # End of login shell setup
# and that's all the magic :-)

