#
## CLE :: Command Live Environment
## author: Michael Arbet (marbet@redhat.com)
## version: 3 2017-02-01
## license: GNU GPL 3
## https://gitlab.cee.redhat.com/marbet/cle
##
# bash tweaks
# - colorized prompt incl exit code highlight
# - builtin aliases and functions
# - history tweaks (timestamps etc), shell options
#
# Execute this file within your shell session once and integrate
# to your profile seamlessly with 'cle deploy local' command
# 
#	$ . clerc
#	$ cle deploy user
#
# * use 'ssg' (ssh wrapper) and seamlessly pass this environment
#   to remote machine without installation
# * try 'suu' (sudo wrapper) with similar effect
# * change settings with implememted 'cle' command
# * built-in self documentation feature ('cle help' & 'cle readme')
# * manage your aliases using 'aa' function

# check running in interactive session and if not, skip all the tweaks
# required for scp compattibility and similar
if [ -n "TERM" -a "$TERM" != "dumb" -a -z "$CLE_EXE" ]; then
CLE_LCLUSER=`whoami`

CLE_RC=${BASH_SOURCE[0]}
case $CLE_RC in
/*)	;;
*)	CLE_RC=$PWD/$CLE_RC ;;
esac
CLE_EXE=$CLE_RC:
CLE_VERSION=`grep -m1 "# version:" $CLE_RC | cut -d' ' -f3-`

# determine effective user and custom script
# CLE_EFUSER is passed to all consecutive sessions initiated with ssg/suu
CLE_CUSTOMRC=$HOME/.cle-${CLE_EFUSER:=$CLE_LCLUSER}

# where in the deep space is CLE growing...
CLE_ORIGIN=https://raw.githubusercontent.com/micharbet/CLE/master
 
# hostname tweak - remove unnecessary parts
# can be altered in e.g. ~/.clerc-local
CLE_HN=`hostname` # |sed s/.mydomain.com//

# default prompt settings
CLE_TIME='\A'
CLE_COLOR='marley'
CLE_WTITLE=1
CLE_PROMPT=$HOME/.cleprompt-$CLE_EFUSER

# color table initializattion
CT_N=`tput sgr0` # reset
CT_L=`tput bold`
CT=`tput setaf 0`; CT_k=$CT_N$CT; CT_K=$CT_L$CT
CT=`tput setaf 1`; CT_r=$CT_N$CT; CT_R=$CT_L$CT
CT=`tput setaf 2`; CT_g=$CT_N$CT; CT_G=$CT_L$CT
CT=`tput setaf 3`; CT_y=$CT_N$CT; CT_Y=$CT_L$CT
CT=`tput setaf 4`; CT_b=$CT_N$CT; CT_B=$CT_L$CT
CT=`tput setaf 5`; CT_m=$CT_N$CT; CT_M=$CT_L$CT
CT=`tput setaf 6`; CT_c=$CT_N$CT; CT_C=$CT_L$CT
CT=`tput setaf 7`; CT_w=$CT_N$CT; CT_W=$CT_L$CT
CT_E=`tput setab 1; tput setaf 7` # err highlight

# default shell settings
export EDITOR=vi
export PAGER="less -s"
HISTFILE=$HOME/.bash_history-$CLE_EFUSER
HISTCONTROL=ignorespace:ignoredups
HISTTIMEFORMAT="%d%b %H:%M:%S  "
PROMPT_DIRTRIM=2
shopt -s checkwinsize

#
# Internal helper functions
#
printb () {
	printf "$CT_L$*$CT_N\n"
}

ask () {
	read -p "$CT_L$*$CT_N"
}

# print banner
_clebanner () {
cat <<EOT

   ___|  |      ____|    Command Live Environment activated
  |      |      __|      ...bit of life to the command line
  |      |      |          $CT_L cle help $CT_N      to learn more 
 \____| _____| _____|    or$CT_L less $CLE_RC $CT_N  to discover the magic
 
EOT
}

# execute script and log its filename into CLE_EXE to keep track
# also ensure the script will be executed only once
_clexe () {
	echo $CLE_EXE|grep -q $1: && return
	[ -f $1 ] && { CLE_EXE=$CLE_EXE$1: ; . $1; }
}

# save prompt related variables
_saveprompt () {
	echo CLE_COLOR=\'$CLE_COLOR\'
	echo CLE_TIME=\'$CLE_TIME\'
} >$CLE_PROMPT


# colorizer
_setcolor () {
	local C0 C1 C2 I II PP
	case "$1" in 
	red)	 C0=$CT_r; C2=$CT_R;;
	green)	 C0=$CT_g; C2=$CT_G;;
	yellow)	 C0=$CT_y; C2=$CT_Y;;
	blue)	 C0=$CT_b; C2=$CT_B;;
	magenta) C0=$CT_m; C2=$CT_M;;
	cyan)	 C0=$CT_c; C2=$CT_C;;
	white|grey|gray) C0=$CT_N; C1=$CT_w; C2=$CT_W;;
	bold)    C0=$CT_L;;
	tricolora) C0=$CT_R; C1=$CT_B; C2=$CT_W;;
	marley) # ... Bob Marley style :-) have a smoke and imagine...
		C0=$CT_R; C1=$CT_Y; C2=$CT_G;;
	???)	# ... any 3 colors
		for I in 0 1 2; do
			II=CT_${1:$I:1}
			[[ -z "${!II}" ]] && echo "bad color code '${1:$I:1}' in $1" && return 2
			declare C$I=${!II}
		done;;
	*)	# print help
		echo " Unknown color '$1', select one of predefined:"
		# self documented function :)
		declare -f _setcolor|sed -n -e 's/\ *\(\<[a-zA-Z |]*\)).*/ \1 /p' |tr '\n' '|'
		printf "\n or create your own 3-letter style from:"
		printf " rgbcmykw and RGBCMYKW \n e.g 'cle color GyY'\n"
		return 2
	esac
	# compose prompts
	[ $UID == 0 ] && PP="#" || PP=">"
	CLE_PS="\[$C0\]\u \[$C1\]$CLE_HN \[$C2\]\w $PP"
	PS2="\[$C0\] >>>\[$CT_N\] "
	CLE_COLOR=$1
	_saveprompt
}

# prompt function - called upon each new prompt line
_cleprompt () {
	local EEP EE=$?  # store exit status code (it would disappear!)
	if [ $EE -eq 0 ]; then
		EEP="\[$CT_K\][$EE]"
	else
		EEP="\[$CT_E\][$EE]\[$CT_N$CT_K\]"
	fi
	# Final prompt composition
	PS1="$EEP${CLE_TIME:+ $CLE_TIME} \[$CT_N\]$CLE_PS\[$CT_N\] "
	# change window title TERMPORARY DISABLED
	[ -z "$CLE_WTITLE" ] && return
	[ "$CLE_EFUSER" != "$LOGNAME" ] && WTU="$CLE_EFUSER ->"
	printf "\033]0;$WTU $LOGNAME@$CLE_HN: $PWD\007"
}
PROMPT_COMMAND=_cleprompt

# indicate first run, show banner
[ -f $CLE_PROMPT ] || { _clebanner; _saveprompt; }
_clexe $CLE_PROMPT
_setcolor $CLE_COLOR

# where the CLE was started?
case $CLE_RC in
*.clerc-remote-*)	# transferred through ssg/suu, run old good .bashrc :-)
	_clexe $HOME/.bashrc
	;;
*/clerc*)	# initial run from commandline
	printf "It seems you started CLE from command line by issuing '. $CLE_RC'\n"
	printf "Since this is your first run, consider setting up in your profile.\n"
	printf "Following command will hook CLE in your $HOME/.bashrc\n\n"
	printb "  cle deploy user\n"
	;;
esac

# local tweaks
_clexe $HOME/.clerc-local

# execute plugins from .cle folder
for PLUG in $HOME/.cle/*; do
	_clexe $PLUG
done

## CLE default aliases and functions:
## ----------------------------------
_defalias () {
	## ls commands aliases: l ll la lt llr l.
	alias ls='ls --color=auto'
	alias l='ls -l'
	alias ll='ls -l'
	alias lt='ls -ltr'
	alias la='ls -al'
	alias llr='ls -lR'
	alias l.='ls -ld .?*'
	## cd command aliases:
	## .. ...     -- up one or two levels
	## cd-        -- cd to recent dir
	## -  (dash)  -- cd to recent dir
	alias ..='cd ..'
	alias ...='cd ../..'
	alias cd-='cd -'
	## xx & cx    -- path bookmark; set and 'cd' later, stored in $XX
	alias xx='XX=`pwd`; echo path boorkmark set here: $XX'
	alias cx='cd $XX'
	alias grep='grep --color=auto'
	alias mv='mv -i'
	alias rm='rm -i'
}

# '-' must be function, alias was troublesome
- () { cd -; }

##
## alias management
## ----------------
CLE_ALIASES=$HOME/.aliases-$CLE_EFUSER # personalized aliases
_clexe $CLE_ALIASES
_defalias

aa () {
	local ALIASBAK=$CLE_ALIASES.back
	case "$1" in
	"") ## aa         -- show aliases
		alias ;;
	save) ## aa save    -- save your set of aliases
		alias
		ask "ENTER for save, Ctrl-C to exit"
		cp $CLE_ALIASES $ALIASBAK
		alias >$CLE_ALIASES
		echo Saved to file: $CLE_ALIASES
		echo Backup in: $ALIASBAK
		;;
	load) ## aa load    -- (re)load your set of aliases
		unalias -a
		. $CLE_ALIASES
		;;
	edit) ## aa edit    -- edit and reload your aliases
		local TALIAS=$CLE_ALIASES.edit
		alias >$ALIASBAK
		cp $ALIASBAK $TALIAS
		vi $TALIAS
		mv $TALIAS $CLE_ALIASES
		aa load
		echo Backup in: $ALIASBAK
		;;
	merge)  # aa merge   -- merge local and remote aliases
		#placeholder
		echo aa merge ... not imlemented yet
		;;
#	fwd)	# aa fwd    -- forward local aliases to remote system with 'ssg'
#		ln -s $CLE_ALIASES ~/.aliases-remote-$CLE_EFUSER
#		;;
	reset)	## aa reset   -- reset default aliases
		## aa reset full -- also remove custom aliases
		alias >$ALIASBAK
		[[ "$2" == full ]] && unalias -a
		_defalias
		aa save
		echo Backup in:  $ALIASBAK
		;;
	*)	
		echo " unimplemented: aa $1 $2"
		cle help aa
                ;;
	esac
}

##
## history management
## ------------------
hh () {
	case $1 in
	"")	## hh         -- just print history
		history
		;;
	s)	## hh s       -- save current history in $HISTFILE
		history -a
		;;
	l)	## hh l       -- load history, use save & load to share history
		history -n
		;;
	[0-9]*)	## hh number  -- print last N entries
		history $1
		;;
	*)
		## hh string  -- search in history
		history | grep $1
		;;
	esac
}

##
## various functions
## -----------------
## path       -- show $PATH in readable way
path () {
	echo $PATH|tr : \\n
}

## psg        -- ps filtered through grep
psg () {
 ps -ef |grep -i $1|grep -v grep
}

## dfh        -- df -h wrapper
dfh () {
	df -h
}

## dush, dusk -- du wrappers
dush () {
	if [ $# -eq 0 ]; then
		du -sh * | sort -h
	else
		du -sh $* | sort -h
	fi
}

dusk () {
	if [ $# -eq 0 ]; then
		du -sk * | sort -n
	else
		du -sk $* | sortn -n
	fi
}

##
## SSH & SUDO wrappers:
## --------------------
## ssg [user@]hostname  -- login to remote system running this environment
ssg () {
	pushd $HOME >/dev/null
	local CLE_RMTRC=.clerc-remote-$CLE_EFUSER
	if [ -n "$1" ]; then
		cp $CLE_RC $CLE_RMTRC 2>/dev/null
		local SSGFILES=$CLE_RMTRC
#		[ -f .aliases-remote-$CLE_EFUSER ] && SSGFILES="$SSGFILES .aliases-remote-$CLE_EFUSER"
		local CLE_64=`tar chzf - $SSGFILES |base64|tr -d '\n\r '`
		`/usr/bin/which ssh` -t $1 "
			echo $CLE_64|base64 --decode |tar xzf -
			export CLE_EFUSER=$CLE_EFUSER;
			exec bash --rcfile $CLE_RMTRC"
	else
		cle help ssg
	fi
	popd >/dev/null
}

## suu [username]       -- sudo wrapper; root is the default account
suu () {
	pushd $HOME >/dev/null
	local CLE_RMTRC=.clerc-remote-$CLE_EFUSER
	cp $CLE_RC $CLE_RMTRC 2>/dev/null
	local CLE_64=`tar czf - $CLE_RMTRC |base64|tr -d '\n\r '`
	sudo -i -u ${1:-root} /bin/bash  -c \
		"echo $CLE_64|base64 --decode| tar xzf -;
		 export CLE_EFUSER=$CLE_EFUSER;
		 exec bash --rcfile $CLE_RMTRC"
	popd >/dev/null
}

##
## CLE command & control:
## ----------------------
cle () {
	case "$1_$2" in
	color_*) ## cle color COLOR    -- set prompt color
		_setcolor $2 ;;
	time_on) ## cle time on|off    -- toggle server time in prompt
		CLE_TIME='\A'
		_saveprompt ;;
	time_off)
		CLE_TIME=''
		_saveprompt ;;
	time_*) ## cle time STRING    -- set custom strings
		shift
		CLE_TIME="$*"
		_saveprompt ;;
	title_on) ## cle title on|off   -- toggle window title
		CLE_WTITLE="1" ;;
	title_off)
		CLE_WTITLE="" ;;
	deploy_user)
		## cle deploy user    -- hook CLE into user's profile
		local CLID='# Command Live Environment'
		local BRC=$HOME/.bashrc
		cp $CLE_RC $HOME/.clerc
		grep -q "$CLID" $BRC 
		if [ $? != 0 ]; then
			echo " CLE is to be integrated to your login script."
			ask " Are you sure? (y/N) "
			[ "$REPLY" != 'y' ] && return
			echo -e >>$BRC \\n$CLID
			echo -e >>$BRC '[ -f $HOME/.clerc ] && . $HOME/.clerc\n'
			printf '\n ... added following to the end of .bashrc :\n'
			tail -4 $BRC
		else
			echo " CLE is already hooked into .bashrc :"
			grep -A2 "$CLID" $BRC
		fi ;;
	deploy_system)
		## cle deploy system  -- hook CLE into /etc/profile.d
		echo " CLE is to be integrated into your system!"
		echo " Content of $CLE_RC will be copied to /etc/profile.d/cle.sh"
		echo " The environment will be activated for all users."
		echo " Only root can do that..."
		ask " Are you sure? (y/N) "
		[ "$REPLY" != 'y' ] && return
		cp $CLE_RC /etc/profile.d/cle.sh
		echo " Done!"
		;;
	update_) ## cle update         -- download newest version of CLE
		curl -k $CLE_ORIGIN/clerc >$HOME/clerc-new
		echo "New CLE has been stored here: $HOME/clerc-new"
		ask "Press Enter to show diff or Ctrl-C to break"
		diff $CLE_RC $HOME/clerc-new
		ask "Do you want to install new version? (y/N) "
		[ "$REPLY" != 'y' ] && return
		cp $CLE_RC $HOME/clerc-orig
		mv $HOME/clerc-new $CLE_RC
		cle reload
		echo "New CLE has been installed, previous version stored here: $HOME/clerc-orig"
		;;
	reload_) ## cle reload         -- reload CLE
		unset CLE_EXE
		. $CLE_RC ;;
	env_)	## cle env            -- print CLE_* variables
		set | grep ^CLE_.*= ;;
	readme_) ## cle readme         -- download and show README file
		curl -k $CLE_ORIGIN/README.md |less ;;
	help_*) ## cle help [cmd]     -- self documenting feature
		# double-hash denotes help content :-)
		[ -z "$2" ] && _clebanner
		awk -F# "/## *$2/"' { print $3 }' $CLE_RC
		;;
	_)	_clebanner ;;
	*)
		if declare -f _cle_$1 >/dev/null; then
			_cle_$1 $2
		else
			echo " cle $1 not implemeted"
			echo " check cle help"
		fi ;;
	esac
}

# enhance path with user's own bin directory
[ -d $HOME/bin ] && echo $PATH | grep -vq $HOME/bin && PATH=$PATH:$HOME/bin

# run personal tweaks
_clexe $CLE_CUSTOMRC

# remove disturbing stuff
unset SUDO_COMMAND

fi # End of login shell setup
# and that's all the magic :-)

